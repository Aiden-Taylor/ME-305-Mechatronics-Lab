
Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
    1    1                      ;**************************************************************************************
    2    2                      ;* Lab 3 Main [includes LibV2.2]                                                      *
    3    3                      ;**************************************************************************************
    4    4                      ;* Summary:                                                                           *
    5    5                      ;*   -                                                                                *
    6    6                      ;*                                                                                    *
    7    7                      ;* Author: Aiden Taylor & Julia Fay                                                   *
    8    8                      ;*   Cal Poly University                                                              *
    9    9                      ;*   Fall 2023                                                                        *
   10   10                      ;*                                                                                    *
   11   11                      ;* Revision History:                                                                  *
   12   12                      ;*   -                                                                                *
   13   13                      ;*                                                                                    *
   14   14                      ;* ToDo:                                                                              *
   15   15                      ;*   -                                                                                *
   16   16                      ;**************************************************************************************
   17   17                      
   18   18                      ;/------------------------------------------------------------------------------------\
   19   19                      ;| Include all associated files                                                       |
   20   20                      ;\------------------------------------------------------------------------------------/
   21   21                      ; The following are external files to be included during assembly
   22   22                      
   23   23                      
   24   24                      ;/------------------------------------------------------------------------------------\
   25   25                      ;| External Definitions                                                               |
   26   26                      ;\------------------------------------------------------------------------------------/
   27   27                      ; All labels that are referenced by the linker need an external definition
   28   28                      
   29   29                                    XDEF  main
   30   30                      
   31   31                      ;/------------------------------------------------------------------------------------\
   32   32                      ;| External References                                                                |
   33   33                      ;\------------------------------------------------------------------------------------/
   34   34                      ; All labels from other files must have an external reference
   35   35                      
   36   36                                    XREF  ENABLE_MOTOR, DISABLE_MOTOR
   37   37                                    XREF  STARTUP_MOTOR, UPDATE_MOTOR, CURRENT_MOTOR
   38   38                                    XREF  STARTUP_PWM, STARTUP_ATD0, STARTUP_ATD1
   39   39                                    XREF  OUTDACA, OUTDACB
   40   40                                    XREF  STARTUP_ENCODER, READ_ENCODER
   41   41                                    XREF  INITLCD, SETADDR, GETADDR, CURSOR_ON, CURSOR_OFF, DISP_OFF
   42   42                                    XREF  OUTCHAR, OUTCHAR_AT, OUTSTRING, OUTSTRING_AT
   43   43                                    XREF  INITKEY, LKEY_FLG, GETCHAR
   44   44                                    XREF  LCDTEMPLATE, UPDATELCD_L1, UPDATELCD_L2
   45   45                                    XREF  LVREF_BUF, LVACT_BUF, LERR_BUF,LEFF_BUF, LKP_BUF, LKI_BUF
   46   46                                    XREF  Entry, ISR_KEYPAD
   47   47                                  
   48   48                      ;/------------------------------------------------------------------------------------\
   49   49                      ;| Assembler Equates                                                                  |
   50   50                      ;\------------------------------------------------------------------------------------/
   51   51                      ; Constant values can be equated here
   52   52                      
   53   53          0000 0258   PORTP EQU $0258 ; output port for LEDs
   54   54          0000 025A   DDRP EQU $025A
   55   55          0000 0010   G_LED_1 EQU %00010000 ; green LED output pin for LED pair_1
   56   56          0000 0020   R_LED_1 EQU %00100000 ; red LED output pin for LED pair_1
   57   57          0000 0030   LED_MSK_1 EQU %00110000 ; LED pair_1
   58   58          0000 0040   G_LED_2 EQU %01000000 ; green LED output pin for LED pair_2
   59   59          0000 0080   R_LED_2 EQU %10000000 ; red LED output pin for LED pair_2
   60   60          0000 00C0   LED_MSK_2 EQU %11000000 ; LED pair_2
   61   61                      
   62   62                      
   63   63                      ;/------------------------------------------------------------------------------------\
   64   64                      ;| Variables in RAM                                                                   |

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
   65   65                      ;\------------------------------------------------------------------------------------/
   66   66                      ; The following variables are located in unpaged ram
   67   67                      
   68   68                      DEFAULT_RAM:  SECTION
   69   69                      
   70   70                      ;params for t1 
   71   71                      
   72   72   000000             COUNT DS.B 1
   73   73   000001             F1_FLG  DS.B 1
   74   74   000002             F2_FLG  DS.B 1
   75   75   000003             ON1     DS.B 1 
   76   76   000004             ON2     DS.B 1 
   77   77   000005             MM_ERR  DS.B 1 
   78   78                      
   79   79                      ;params for t2 
   80   80   000006             KEY_FLG DS.B 1
   81   81   000007             KEY_BUFF DS.B 1
   82   82                      
   83   83                      ;params for t3
   84   84   000008             MSG_NUM DS.B 1
   85   85                      
   86   86                      
   87   87                      ;params for t4
   88   88                      
   89   89   000009             DONE_1 DS.B 1
   90   90                      
   91   91                      ;params for t5
   92   92                      
   93   93   00000A             TICKS_1 DS.W 1
   94   94   00000C             COUNT_1 DS.W 1
   95   95                      
   96   96                      ;params for t6
   97   97                      
   98   98   00000E             DONE_2 DS.B 1
   99   99                      
  100  100                      ;params for t7
  101  101                      
  102  102   00000F             TICKS_2 DS.W 1
  103  103   000011             COUNT_2 DS.W 1
  104  104                      
  105  105                      ;params for t8
  106  106                      
  107  107                          ;delay
  108  108                      
  109  109                      
  110  110                      ;state vars
  111  111   000013             t1state DS.B 1
  112  112   000014             t2state DS.B 1
  113  113   000015             t3state DS.B 1
  114  114   000016             t4state DS.B 1
  115  115   000017             t5state DS.B 1
  116  116   000018             t6state DS.B 1
  117  117   000019             t7state DS.B 1
  118  118   00001A             t8state DS.B 1
  119  119                      
  120  120                      ;subroutines ---------
  121  121                      
  122  122                      ;convert
  123  123   00001B             RESULT DS.W 1 
  124  124   00001D             BUFFER DS.B 5
  125  125   000022             TMP DS.B 1
  126  126   000023             ERR DS.B 1 
  127  127                      
  128  128                      ;input

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  129  129   000024             INPUT DS.B 1
  130  130   000025             DPTR DS.W 1
  131  131   000027             FIRSTCH DS.B 1
  132  132                      
  133  133                      ;/------------------------------------------------------------------------------------\
  134  134                      ;|  Main Program Code                                                                 |
  135  135                      ;\------------------------------------------------------------------------------------/
  136  136                      ; Your code goes here
  137  137                      
  138  138                      MyCode:       SECTION
  139  139                      main:  
  140  140   000000 79xx xx            clr t1state ; initialize all tasks to state0
  141  141   000003 79xx xx            clr t2state
  142  142   000006 79xx xx            clr t3state
  143  143   000009 79xx xx            clr t4state
  144  144   00000C 79xx xx            clr t5state
  145  145   00000F 79xx xx            clr t6state
  146  146   000012 79xx xx            clr t7state
  147  147   000015 79xx xx            clr t8state
  148  148                             
  149  149                      Top:
  150  150                              ;bgnd
  151  151   000018 16xx xx             jsr TASK_1 ; execute tasks endlessly
  152  152   00001B 16xx xx             jsr TASK_2
  153  153   00001E 16xx xx             jsr TASK_3
  154  154   000021 16xx xx             jsr TASK_4
  155  155   000024 16xx xx             jsr TASK_5
  156  156   000027 16xx xx             jsr TASK_6
  157  157   00002A 16xx xx             jsr TASK_7
  158  158   00002D 16xx xx             jsr TASK_8
  159  159   000030 20E6                bra Top       
  160  160                             
  161  161   000032 20FE        spin: bra spin
  162  162                      
  163  163                      ;-------------TASK_1 MASTERMIND ---------------------------------------------------------
  164  164                      
  165  165                      TASK_1: 
  166  166                              ;bgnd
  167  167   000034 B6xx xx             ldaa t1state ; get current t1state and branch accordingly
  168  168   000037 2720                beq t1s0
  169  169   000039 43                  deca
  170  170   00003A 2735                beq t1s1
  171  171   00003C 43                  deca
  172  172   00003D 276F                beq t1s2
  173  173   00003F 43                  deca
  174  174   000040 1827 009D           lbeq t1s3
  175  175   000044 43                  deca
  176  176   000045 1827 010B           lbeq t1s4
  177  177   000049 43                  deca
  178  178   00004A 1827 0117           lbeq t1s5
  179  179   00004E 43                  deca
  180  180   00004F 1827 012C           lbeq t1s6
  181  181   000053 43                  deca
  182  182   000054 1827 0141           lbeq t1s7
  183  183   000058 3D                  rts ; undefined state - do nothing but return
  184  184                      ;__________________________________________________________________________________
  185  185                      t1s0: ; init TASK_1
  186  186                      
  187  187                      ;clear all of the flags 
  188  188   000059 79xx xx             clr TICKS_1
  189  189   00005C 79xx xx             clr TICKS_2
  190  190   00005F 79xx xx             clr F1_FLG 
  191  191   000062 79xx xx             clr F2_FLG 
  192  192   000065 79xx xx             clr KEY_FLG 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  193  193   000068 79xx xx             clr COUNT 
  194  194   00006B 180B 01xx           movb #$01, t1state ; set next state
             00006F xx         
  195  195   000070 3D                  rts
  196  196                      ;__________________________________________________________________________________
  197  197                      t1s1: ;
  198  198                      
  199  199                      ;check if its F1
  200  200                       
  201  201   000071 F7xx xx             tst KEY_FLG                                 ;first test if there is a key to be checked
  202  202   000074 1827 016F           lbeq exit1                                  ;if there is no 
  203  203   000078 B6xx xx             ldaa KEY_BUFF                                ;load accumulator A with the current char
  204  204   00007B 81F1                cmpa #$F1                                     ;compare whats in A to F1 
  205  205   00007D 2606                bne skipF1                                  ;if its not F1, skip settting the state
  206  206   00007F 180B 05xx           movb #$05 , t1state                         ;set the state to the appropriate number  
             000083 xx         
  207  207   000084 3D                  rts
  208  208                      
  209  209                      skipF1:  
  210  210                      
  211  211                      ;check if its F2
  212  212                                                
  213  213   000085 81F2                cmpa #$F2                                    ;compare whats in A to F2
  214  214   000087 2606                bne skipF2                                  ;if its not F2, skip settting the state
  215  215   000089 180B 06xx           movb #$06 , t1state                         ;set the state to the appropriate number 
             00008D xx         
  216  216   00008E 3D                  rts
  217  217                      
  218  218                      skipF2:
  219  219                      
  220  220                      ;check if its a BS 
  221  221                             
  222  222   00008F 8108                cmpa #$08                                    ;compare whats in A to BS 
  223  223   000091 2606                bne skipBS                                  ;if its not BS, skip settting the state 
  224  224   000093 180B 04xx           movb #$04 , t1state                         ;set the state to the appropriate number 
             000097 xx         
  225  225   000098 3D                  rts
  226  226                      
  227  227                      skipBS: 
  228  228                      
  229  229                      ;check if its a ENT  
  230  230                      
  231  231   000099 810A                cmpa #$0A                                    ;compare whats in A to ENT 
  232  232   00009B 2606                bne skipENT                                 ;if its not BS, skip settting the state 
  233  233   00009D 180B 03xx           movb #$03 , t1state                         ;set the state to the appropriate number 
             0000A1 xx         
  234  234   0000A2 3D                  rts
  235  235                              
  236  236                      skipENT: 
  237  237                      
  238  238                      ;check if its a digit 
  239  239                             
  240  240   0000A3 8139                cmpa #$39                                   ;check if what in A is a number 
  241  241   0000A5 2E06                bgt skipDIGIT                               ;if its not a number, disregard the input 
  242  242   0000A7 180B 02xx           movb #$02 , t1state                         ;set the state to digit handler 
             0000AB xx         
  243  243   0000AC 3D                  rts
  244  244                      
  245  245                      skipDIGIT: 
  246  246                      
  247  247   0000AD 3D                  rts
  248  248                      
  249  249                      ;___________________________________________________________________________________
  250  250                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  251  251                      t1s2: ;Digit Handler 
  252  252                      
  253  253                      ;checks if we should proceed with the digit handler state 
  254  254                      
  255  255   0000AE F7xx xx             tst F1_FLG                                  ;test F1 flag 
  256  256   0000B1 260C                bne skip_e                                  ;if not equal to 0, skip exiting 
  257  257   0000B3 F7xx xx             tst F2_FLG                                  ;test the F2 flag 
  258  258   0000B6 2607                bne skip_e                                  ;if not equal to 0, skip exiting 
  259  259   0000B8 79xx xx             clr KEY_FLG
  260  260   0000BB 1820 0128           lbra exit1                                   ;exit if equal to 0 
  261  261                      
  262  262                      skip_e:
  263  263                      
  264  264                      ;now proceed with the digit handler
  265  265                         
  266  266   0000BF CDxx xx             ldy #BUFFER                                 ;load index register y with buffer 
  267  267   0000C2 B6xx xx             ldaa COUNT                                  ;load A with the current value of COUNT 
  268  268   0000C5 F6xx xx             ldab KEY_BUFF                               ;load b with KEY_BUFF 
  269  269   0000C8 6BEC                stab a,y                                    ;store the contents of b at the position of COUNT in BUFFER
  270  270                             
  271  271   0000CA 72xx xx             inc COUNT                                   ;increment count 
  272  272   0000CD 180B 00xx           movb #$00, KEY_FLG                          ;set key flag to 0 to acknowledge KEYPAD
             0000D1 xx         
  273  273   0000D2 180B 01xx           movb #$01 , t1state                         ;set the state back to 1
             0000D6 xx         
  274  274   0000D7 79xx xx             clr KEY_FLG                                 ;clear key flag 
  275  275   0000DA 16xx xx             jsr OUTCHAR
  276  276   0000DD 1820 0106           lbra exit1                                   ;exit 
  277  277                      ;________________________________________________________________________________________
  278  278                      t1s3: ;ENT 
  279  279                       
  280  280                      
  281  281                      ;before jsr to conversion, check if any digits have been entered into buffer      
  282  282                            
  283  283   0000E1 F7xx xx            tst COUNT                                   ;test the current value of count 
  284  284   0000E4 2604               bne skip_NO_DIGITS                          ;if the count is not zero, branch 
  285  285   0000E6 8603               ldaa #$03                                   ;if the count is zero, put an error code into A 
  286  286   0000E8 2023               bra skip_F2                                 ;branch to the set error state below 
  287  287                             
  288  288                      
  289  289                      skip_NO_DIGITS: 
  290  290                      
  291  291                      ;send to conversion to get a BCD form of the input 
  292  292                          
  293  293   0000EA 16xx xx            jsr conversion                              ;convert the contents of buffer to binary 
  294  294   0000ED 79xx xx            clr COUNT                                   ;set count back to zero 
  295  295   0000F0 79xx xx            clr BUFFER                                  ;clear the contents of the BUFFER
  296  296                             
  297  297                      ;check which ON flag to set 
  298  298                       
  299  299   0000F3 F7xx xx            tst F1_FLG                                  ;test the F1 flag
  300  300   0000F6 2708               beq skip_F1_a                               ;if the flag is zero, skip the next steps 
  301  301   0000F8 180B 01xx          movb #01, ON1                               ;if the flag is 1, set ON1 to be true 
             0000FC xx         
  302  302   0000FD 7Exx xx            stx TICKS_1                                 ;store the results of the conversion 
  303  303                               
  304  304                      skip_F1_a:  
  305  305                       
  306  306   000100 F7xx xx            tst F2_FLG                                  ;test the F2 flag
  307  307   000103 2708               beq skip_F2                                 ;if the flag is zero, skip the next steps 
  308  308   000105 180B 01xx          movb #$01, ON2                              ;if the flag is 1, set ON2 to be true 
             000109 xx         
  309  309   00010A 7Exx xx            stx TICKS_2                                 ;store the results of the conversion
  310  310                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  311  311                      skip_F2:
  312  312                      
  313  313                      ;automatically set the state back to 1 for all cases  
  314  314                      
  315  315   00010D 180B 01xx          movb #$01, t1state                          ;set the state back to 1 
             000111 xx         
  316  316                             
  317  317                      ;check for error and set variables accordingly so that user has to start over 
  318  318                      
  319  319   000112 8100               cmpa #$00                                   ;check whats in A 
  320  320   000114 272B               beq skipERROR                               ;check if an error was generated from conversion
  321  321   000116 180B 07xx          movb #$07, t1state                          ;if there is an error code set the state to the 
             00011A xx         
  322  322                                                                         ;error state
  323  323   00011B 7Axx xx            staa MM_ERR                                 ;store the error code of accumulator A into a variable 
  324  324                                                                         ;so it is not affected by other code before it gets to 
  325  325                                                                         ;the error state                                              
  326  326                                                                           
  327  327                      ;check which ON variable needs to be cleared if there is an error 
  328  328                            
  329  329   00011E F7xx xx           tst F1_FLG                                   ;test the F1 flag
  330  330   000121 2706              beq skip_F1_b                                ;if the flag is zero, skip the next steps 
  331  331   000123 79xx xx           clr ON1                                      ;clear ON1
  332  332   000126 79xx xx           clr TICKS_1                                  ;clear TICKS_1
  333  333                            
  334  334                      skip_F1_b: 
  335  335                       
  336  336   000129 F7xx xx           tst F2_FLG                                   ;test the F2 flag
  337  337   00012C 2713              beq skipERROR                                ;if the flag is zero, skip the next steps
  338  338   00012E 79xx xx           clr ON2                                      ;clear ON2 
  339  339   000131 79xx xx           clr TICKS_2                                  ;clear TICKS_2
  340  340   000134 79xx xx           clr KEY_FLG                                  ;clear key flag
  341  341   000137 16xx xx           jsr clearbuffer
  342  342   00013A 16xx xx           jsr CURSOR_OFF   
  343  343   00013D 1820 00A6         lbra exit1                                   ;exit without clearing F1 and F2 flags 
  344  344                                        
  345  345                      skipERROR:
  346  346                      
  347  347                      ;if there are no errors, clear the F1 and F2 flags and exit   
  348  348                            
  349  349                            
  350  350                            
  351  351   000141 16xx xx           jsr clearbuffer
  352  352   000144 16xx xx           jsr CURSOR_OFF 
  353  353   000147 79xx xx           clr KEY_FLG 
  354  354   00014A 79xx xx           clr F1_FLG 
  355  355   00014D 79xx xx           clr F2_FLG  
  356  356   000150 1820 0093         lbra exit1                                    ;exit
  357  357                       ;________________________________________________________________________________________
  358  358                      t1s4: ;BS
  359  359                       
  360  360   000154 180B 03xx          movb #$03 , t3state                         ;set the state in task 3 to the BS state   
             000158 xx         
  361  361   000159 180B 01xx          movb #$01 , t1state                         ;set the state back to 1
             00015D xx         
  362  362   00015E 79xx xx            clr KEY_FLG 
  363  363   000161 1820 0082          lbra exit1                                   ;exit
  364  364                       ;________________________________________________________________________________________
  365  365                      t1s5: ;F1 state 
  366  366                       
  367  367                             
  368  368   000165 180B 01xx          movb #$01, F1_FLG                           ;set the F1_FLG to be true
             000169 xx         
  369  369   00016A 180B 01xx          movb #$01 , t1state                         ;set the state back to 1

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             00016E xx         
  370  370   00016F 79xx xx            clr ON1 
  371  371   000172 79xx xx            clr KEY_FLG
  372  372   000175 8608               ldaa #$08
  373  373   000177 16xx xx            jsr SETADDR
  374  374   00017A 16xx xx            jsr CURSOR_ON 
  375  375   00017D 2068               bra exit1                                   ;exit
  376  376                             
  377  377                       ;________________________________________________________________________________________
  378  378                      t1s6: ;F2 state 
  379  379                       
  380  380   00017F 180B 01xx          movb #$01, F2_FLG                           ;set the F2_FLG to be true
             000183 xx         
  381  381   000184 180B 01xx          movb #$01 , t1state                         ;set the state back to 1
             000188 xx         
  382  382   000189 79xx xx            clr ON2
  383  383   00018C 79xx xx            clr KEY_FLG
  384  384   00018F 8648               ldaa #$48
  385  385   000191 16xx xx            jsr SETADDR
  386  386   000194 16xx xx            jsr CURSOR_ON  
  387  387   000197 204E               bra exit1                                   ;exit
  388  388                      
  389  389                      ;________________________________________________________________________________________
  390  390                      t1s7: ;Error state 
  391  391                      
  392  392                      
  393  393                      ;checks the error code in accumulator A and which F flag is set to set the appropiate fixed 
  394  394                      ;message state to be displayed through task 3 
  395  395                      
  396  396                      ;split the code into two sections. the F1 and F2 sections 
  397  397                        
  398  398                      ;fist test the F1 flag 
  399  399                      
  400  400   000199 F7xx xx            tst F1_FLG                                   ;test the F1 flag
  401  401   00019C 271E               beq skip_F1_e                                ;if the flag is zero, skip the next steps    
  402  402                       
  403  403                      ;now check the error number and set the message number for task 3 
  404  404                       
  405  405   00019E B6xx xx            ldaa MM_ERR                                  ;put the error number back into accumulator a 
  406  406   0001A1 8101               cmpa #01                                     ;check if the error code is mag to large 
  407  407   0001A3 2605               bne skip_F1_toolarge                         ;skip setting the message num
  408  408   0001A5 180B 07xx          movb #$07, MSG_NUM                           ;set the appropiate message num 
             0001A9 xx         
  409  409                      
  410  410                      skip_F1_toolarge: 
  411  411                      
  412  412   0001AA 8102               cmpa #02                                     ;check if the error code is zero magnitude 
  413  413   0001AC 2605               bne skip_F1_zeromag                          ;skip setting the message num
  414  414   0001AE 180B 05xx          movb #$05, MSG_NUM                           ;set the appropiate message num 
             0001B2 xx         
  415  415                      
  416  416                      skip_F1_zeromag: 
  417  417                      
  418  418   0001B3 8103               cmpa #03                                     ;check if the error code is zero digits
  419  419   0001B5 2605               bne skip_F1_e                                ;skip setting the message num
  420  420   0001B7 180B 03xx          movb #$03, MSG_NUM                           ;set the appropiate message num    
             0001BB xx         
  421  421                         
  422  422                      skip_F1_e: 
  423  423                       
  424  424                      ;now test the F2 flag 
  425  425                       
  426  426   0001BC F7xx xx            tst F2_FLG                                   ;test the F1 flag
  427  427   0001BF 271B               beq skip_F2_e                                ;if the flag is zero, skip the next steps    

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  428  428                       
  429  429                      ;now check the error number and set the message number for task 3 
  430  430                       
  431  431   0001C1 8101               cmpa #01                                     ;check if the error code is mag to large 
  432  432   0001C3 2605               bne skip_F2_toolarge                         ;skip setting the message num
  433  433   0001C5 180B 08xx          movb #$08, MSG_NUM                           ;set the appropiate message num 
             0001C9 xx         
  434  434                      
  435  435                      skip_F2_toolarge: 
  436  436                      
  437  437   0001CA 8102               cmpa #02                                     ;check if the error code is zero magnitude 
  438  438   0001CC 2605               bne skip_F2_zeromag                          ;skip setting the message num
  439  439   0001CE 180B 06xx          movb #$06, MSG_NUM                           ;set the appropiate message num 
             0001D2 xx         
  440  440                      
  441  441                      skip_F2_zeromag: 
  442  442                      
  443  443   0001D3 8103               cmpa #03                                     ;check if the error code is zero digits
  444  444   0001D5 2605               bne skip_F2_e                                ;skip setting the message num
  445  445   0001D7 180B 04xx          movb #$04, MSG_NUM                           ;set the appropiate message num 
             0001DB xx         
  446  446                       
  447  447                      skip_F2_e: 
  448  448                      
  449  449                       ;clear the F1 and F2 flags and fall through to the exit 
  450  450                      
  451  451   0001DC 79xx xx             clr F1_FLG 
  452  452   0001DF 79xx xx             clr F2_FLG
  453  453   0001E2 180B 01xx           movb #$01 , t1state                         ;set the state back to 1
             0001E6 xx         
  454  454                      
  455  455                      exit1:
  456  456   0001E7 3D                  rts
  457  457                      ;----------------------TASK 2 - KEYPAD -------------------------------------------; 
  458  458                       
  459  459                      TASK_2:
  460  460                       
  461  461                              ;bgnd
  462  462   0001E8 B6xx xx             ldaa t2state ;get state
  463  463   0001EB 2707                beq t2s0
  464  464   0001ED 43                  deca
  465  465   0001EE 270D                beq t2s1
  466  466   0001F0 43                  deca
  467  467   0001F1 2721                beq t2s2
  468  468   0001F3 3D                  rts
  469  469                      
  470  470                      t2s0:
  471  471                      
  472  472                              ;init
  473  473                              
  474  474   0001F4 16xx xx             jsr INITKEY       ;initialize keypad
  475  475   0001F7 180B 01xx           movb #$01, t2state
             0001FB xx         
  476  476   0001FC 3D                  rts
  477  477                              
  478  478                      t2s1:     
  479  479                         
  480  480   0001FD F7xx xx             tst LKEY_FLG
  481  481   000200 271C                beq exit2
  482  482   000202 16xx xx             jsr GETCHAR
  483  483   000205 7Bxx xx             stab KEY_BUFF     ;stores the input char into key buffer
  484  484   000208 180B 01xx           movb #$01, KEY_FLG        ;notifies MM of key input
             00020C xx         
  485  485   00020D 180B 02xx           movb #$02, t2state

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000211 xx         
  486  486   000212 200A                bra exit2                                   ;exit
  487  487                              
  488  488                      t2s2:
  489  489                      
  490  490   000214 F7xx xx             tst KEY_FLG
  491  491   000217 2605                bne exit2
  492  492   000219 180B 01xx           movb #$01, t2state
             00021D xx         
  493  493                              
  494  494                      
  495  495   00021E 3D          exit2: rts        
  496  496                              
  497  497                              
  498  498                      ;---------------------TASK 3 - DISPLAY ---------------------------------------------;
  499  499                      
  500  500                      TASK_3:
  501  501                      
  502  502   00021F B6xx xx             ldaa t3state
  503  503   000222 2728                beq t3s0
  504  504   000224 43                  deca
  505  505   000225 2738                beq t3s1
  506  506   000227 43                  deca
  507  507   000228 2741                beq t3s2
  508  508   00022A 43                  deca
  509  509   00022B 2742                beq t3s3
  510  510   00022D 43                  deca
  511  511   00022E 274D                beq t3s4
  512  512   000230 43                  deca
  513  513   000231 2758                beq t3s5
  514  514   000233 43                  deca
  515  515   000234 2763                beq t3s6
  516  516   000236 43                  deca
  517  517   000237 276E                beq t3s7
  518  518   000239 43                  deca
  519  519   00023A 2779                beq t3s8
  520  520   00023C 43                  deca
  521  521   00023D 1827 0082           lbeq t3s9
  522  522   000241 43                  deca
  523  523   000242 1827 008B           lbeq t3s10
  524  524   000246 43                  deca
  525  525   000247 1827 0094           lbeq t3s11
  526  526   00024B 3D                  rts
  527  527                              
  528  528                      t3s0:     ;init    
  529  529                              
  530  530   00024C 16xx xx            jsr INITLCD       ;initialize LCD
  531  531   00024F 180B 01xx          movb #$01, FIRSTCH
             000253 xx         
  532  532   000254 8600               ldaa #$00         ;set LCD position to 0
  533  533   000256 16xx xx            jsr SETADDR
  534  534                             ;jsr CURSOR_ON     ;turn on cursor
  535  535   000259 180B 0Bxx          movb #$0B, t3state ; go to init state 
             00025D xx         
  536  536   00025E 3D                 rts
  537  537                              
  538  538                      t3s1:
  539  539                      
  540  540                             ;hub
  541  541   00025F 180B 01xx          movb #$01, FIRSTCH
             000263 xx         
  542  542   000264 F6xx xx            ldab MSG_NUM            
  543  543   000267 7Bxx xx            stab t3state            
  544  544   00026A 3D                 rts

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  545  545                      
  546  546                      
  547  547                      t3s2:   ;backspace
  548  548   00026B 16xx xx             jsr backspace
  549  549   00026E 3D                  rts
  550  550                      
  551  551                              
  552  552                      t3s3:   ;full time1 message     
  553  553   00026F 8600                ldaa #$00
  554  554   000271 CExx xx             ldx #TIME1
  555  555   000274 F7xx xx             tst FIRSTCH
  556  556   000277 2676                bne char1
  557  557   000279 16xx xx             jsr PUTCHAR
  558  558   00027C 3D                  rts
  559  559                              
  560  560                              
  561  561                      t3s4:   ;full time2 message
  562  562   00027D 8640                ldaa #$40
  563  563   00027F CExx xx             ldx #TIME2
  564  564   000282 F7xx xx             tst FIRSTCH
  565  565   000285 2668                bne char1
  566  566   000287 16xx xx             jsr PUTCHAR
  567  567   00028A 3D                  rts
  568  568                      
  569  569                      
  570  570                      t3s5:   ;no digit 1 message
  571  571   00028B 8600                ldaa #$00
  572  572   00028D CExx xx             ldx #NODIG1
  573  573   000290 F7xx xx             tst FIRSTCH
  574  574   000293 265A                bne char1
  575  575   000295 16xx xx             jsr PUTCHAR
  576  576   000298 3D                  rts
  577  577                      
  578  578                      
  579  579                      t3s6:   ;no digit 2 message
  580  580   000299 8640                ldaa #$40
  581  581   00029B CExx xx             ldx #NODIG2
  582  582   00029E F7xx xx             tst FIRSTCH
  583  583   0002A1 264C                bne char1
  584  584   0002A3 16xx xx             jsr PUTCHAR
  585  585   0002A6 3D                  rts
  586  586                              
  587  587                      
  588  588                      t3s7:   ;zero magnitude 1 message
  589  589   0002A7 8600                ldaa #$00
  590  590   0002A9 CExx xx             ldx #ZMAG1
  591  591   0002AC F7xx xx             tst FIRSTCH
  592  592   0002AF 263E                bne char1
  593  593   0002B1 16xx xx             jsr PUTCHAR
  594  594   0002B4 3D                  rts
  595  595                      
  596  596                      t3s8:   ;zero magnitude 2 message
  597  597   0002B5 8640                ldaa #$40
  598  598   0002B7 CExx xx             ldx #ZMAG2
  599  599   0002BA F7xx xx             tst FIRSTCH
  600  600   0002BD 2630                bne char1
  601  601   0002BF 16xx xx             jsr PUTCHAR
  602  602   0002C2 3D                  rts
  603  603                      
  604  604                      t3s9:   ;magnitude too large 1 message
  605  605   0002C3 8600                ldaa #$00
  606  606   0002C5 CExx xx             ldx #MAGTL1
  607  607   0002C8 F7xx xx             tst FIRSTCH
  608  608   0002CB 2622                bne char1

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  609  609   0002CD 16xx xx             jsr PUTCHAR
  610  610   0002D0 3D                  rts
  611  611                      
  612  612                      
  613  613                      t3s10:  ;magnitude too large 2 message
  614  614   0002D1 8640                ldaa #$40
  615  615   0002D3 CExx xx             ldx #MAGTL2
  616  616   0002D6 F7xx xx             tst FIRSTCH
  617  617   0002D9 2614                bne char1
  618  618   0002DB 16xx xx             jsr PUTCHAR
  619  619   0002DE 3D                  rts
  620  620                      
  621  621                      t3s11:  ;display full screen (init message)
  622  622                      
  623  623   0002DF CExx xx            ldx #INITMSG
  624  624   0002E2 F7xx xx            tst FIRSTCH
  625  625   0002E5 2604               bne initmsg
  626  626   0002E7 16xx xx            jsr ICHAR
  627  627   0002EA 3D                 rts
  628  628                             
  629  629                      initmsg: ;first char of init message
  630  630                             
  631  631   0002EB 16xx xx            jsr ICHAR1
  632  632   0002EE 3D                 rts
  633  633                             
  634  634                      char1:    ;first char of any message
  635  635                      
  636  636   0002EF 16xx xx            jsr PUTCHAR1
  637  637   0002F2 3D                 rts 
  638  638                              
  639  639                      exit3:
  640  640                      
  641  641   0002F3 3D                 rts
  642  642                             
  643  643                      ;------------------TASK 4--------------------------------------------------
  644  644                      ;pattern 1
  645  645                      
  646  646                      TASK_4: 
  647  647                              ;bgnd
  648  648   0002F4 F7xx xx             tst ON1
  649  649   0002F7 2718                beq turnofft4
  650  650                              
  651  651   0002F9 B6xx xx             ldaa t4state ; get current t4state and branch accordingly
  652  652   0002FC 271D                beq t4state0
  653  653   0002FE 43                  deca
  654  654   0002FF 272B                beq t4state1
  655  655   000301 43                  deca
  656  656   000302 2737                beq t4state2
  657  657   000304 43                  deca
  658  658   000305 2743                beq t4state3
  659  659   000307 43                  deca
  660  660   000308 274F                beq t4state4
  661  661   00030A 43                  deca
  662  662   00030B 275B                beq t4state5
  663  663   00030D 43                  deca
  664  664   00030E 2767                beq t4state6
  665  665   000310 3D                  rts ; undefined state - do nothing but return
  666  666                              
  667  667                      turnofft4:
  668  668                              ;changes lights to off
  669  669   000311 1D02 5830           bclr PORTP, LED_MSK_1
  670  670   000315 180B 01xx           movb #$01, t4state
             000319 xx         
  671  671   00031A 3D                  rts

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  672  672                              
  673  673                              
  674  674                      t4state0: ; init TASK_1 (not G, not R)
  675  675   00031B 79xx xx             clr ON1
  676  676   00031E 1D02 5830           bclr PORTP, LED_MSK_1 ; ensure that LEDs are off when initialized
  677  677   000322 1C02 5A30           bset DDRP, LED_MSK_1 ; set LED_MSK_1 pins as PORTS outputs
  678  678   000326 180B 01xx           movb #$01, t4state ; set next state
             00032A xx         
  679  679   00032B 3D                  rts
  680  680                              
  681  681                      t4state1: ; G, not R
  682  682   00032C 1C02 5810           bset PORTP, G_LED_1 ; set state1 pattern on LEDs
  683  683   000330 F7xx xx             tst DONE_1 ; check TASK_4 done flag
  684  684   000333 2705                beq exit_t4s1 ; if not done, return
  685  685   000335 180B 02xx           movb #$02, t4state ; otherwise if done, set next state
             000339 xx         
  686  686                      exit_t4s1:
  687  687   00033A 3D                  rts
  688  688                              
  689  689                      t4state2: ; not G, not R
  690  690   00033B 1D02 5810           bclr PORTP, G_LED_1 ; set state2 pattern on LEDs
  691  691   00033F F7xx xx             tst DONE_1 ; check TASK_4 done flag
  692  692   000342 2705                beq exit_t4s2 ; if not done, return
  693  693   000344 180B 03xx           movb #$03, t4state ; otherwise if done, set next state
             000348 xx         
  694  694                      exit_t4s2:
  695  695   000349 3D                  rts
  696  696                              
  697  697                      t4state3: ; not G, R
  698  698   00034A 1C02 5820           bset PORTP, R_LED_1 ; set state3 pattern on LEDs
  699  699   00034E F7xx xx             tst DONE_1 ; check TASK_4 done flag
  700  700   000351 2705                beq exit_t4s3 ; if not done, return
  701  701   000353 180B 04xx           movb #$04, t4state ; otherwise if done, set next state
             000357 xx         
  702  702                      exit_t4s3:
  703  703   000358 3D                  rts
  704  704                              
  705  705                      t4state4 ; not G, not R
  706  706   000359 1D02 5820           bclr PORTP, R_LED_1 ; set state4 pattern on LEDs
  707  707   00035D F7xx xx             tst DONE_1 ; check TASK_4 done flag
  708  708   000360 2705                beq exit_t4s4 ; if not done, return
  709  709   000362 180B 05xx           movb #$05, t4state ; otherwise if done, set next state
             000366 xx         
  710  710                      exit_t4s4:
  711  711   000367 3D                  rts
  712  712                              
  713  713                      t4state5: ; G, R
  714  714   000368 1C02 5830           bset PORTP, LED_MSK_1 ; set state5 pattern on LEDs
  715  715   00036C F7xx xx             tst DONE_1 ; check TASK_4 done flag
  716  716   00036F 2705                beq exit_t4s5 ; if not done, return
  717  717   000371 180B 06xx           movb #$06, t4state ; otherwise if done, set next state
             000375 xx         
  718  718                      exit_t4s5:
  719  719   000376 3D                  rts
  720  720                              
  721  721                      t4state6: ; not G, not R
  722  722   000377 1D02 5830           bclr PORTP, LED_MSK_1 ; set state6 pattern on LEDs
  723  723   00037B F7xx xx             tst DONE_1 ; check TASK_4 done flag
  724  724   00037E 2705                beq exit_t4s6 ; if not done, return
  725  725   000380 180B 01xx           movb #$01, t4state ; otherwise if done, set next state
             000384 xx         
  726  726                      exit_t4s6:
  727  727   000385 3D                  rts ; exit TASK_4
  728  728                       

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  729  729                      
  730  730                      
  731  731                      ;------------------TASK 5--------------------------------------------------
  732  732                      ;timing 1
  733  733                      
  734  734   000386 B6xx xx     TASK_5: ldaa t5state ; get current t5state and branch accordingly
  735  735   000389 2704                beq t5state0
  736  736   00038B 43                  deca
  737  737   00038C 2710                beq t5state1
  738  738   00038E 3D                  rts ; undefined state - do nothing but return
  739  739                              
  740  740                      t5state0: ; initialization for TASK_5
  741  741   00038F 1804 xxxx           movw TICKS_1, COUNT_1 ; init COUNT_1
             000393 xxxx       
  742  742   000395 79xx xx             clr DONE_1 ; init DONE_1 to FALSE
  743  743   000398 180B 01xx           movb #$01, t5state ; set next state
             00039C xx         
  744  744   00039D 3D                  rts
  745  745                              
  746  746                      t5state1: ; Countdown_1
  747  747   00039E B6xx xx             ldaa DONE_1   ;load accumulator A with DONE_1 
  748  748   0003A1 8101                cmpa #$01     ;check if DONE_1 - 1 = 0 
  749  749   0003A3 2609                bne t5s1a ; skip reinitialization if DONE_1 is not = 1
  750  750                              
  751  751                              ;reinitialize if DONE_1 = 1 
  752  752                              
  753  753   0003A5 1804 xxxx           movw TICKS_1, COUNT_1 ; init COUNT_1
             0003A9 xxxx       
  754  754   0003AB 79xx xx             clr DONE_1 ; init DONE_1 to FALSE
  755  755                              
  756  756                             ;after reinitialization, you still decrement
  757  757                              
  758  758   0003AE 1873 xxxx   t5s1a:  decw COUNT_1    ;decrement COUNT_1
  759  759   0003B2 2605                bne exit_t5s2   ;if COUNT_1 is not equal to zero, exit 
  760  760   0003B4 180B 01xx           movb #$01, DONE_1     ;if COUNT_1 is zero, set DONE_1 to 1
             0003B8 xx         
  761  761                           
  762  762                              
  763  763                      exit_t5s2:
  764  764   0003B9 3D                  rts ; exit TASK_5
  765  765                      
  766  766                      
  767  767                      
  768  768                      
  769  769                      
  770  770                      
  771  771                      ;------------------TASK 6--------------------------------------------------
  772  772                      ;pattern 2
  773  773                      
  774  774                      TASK_6: 
  775  775   0003BA F7xx xx             tst ON2
  776  776   0003BD 2718                beq turnofft6
  777  777                      
  778  778   0003BF B6xx xx             ldaa t6state ; get current t1state and branch accordingly
  779  779   0003C2 271D                beq t6state0
  780  780   0003C4 43                  deca
  781  781   0003C5 272B                beq t6state1
  782  782   0003C7 43                  deca
  783  783   0003C8 2737                beq t6state2
  784  784   0003CA 43                  deca
  785  785   0003CB 2743                beq t6state3
  786  786   0003CD 43                  deca
  787  787   0003CE 274F                beq t6state4
  788  788   0003D0 43                  deca

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  789  789   0003D1 275B                beq t6state5
  790  790   0003D3 43                  deca
  791  791   0003D4 2767                beq t6state6
  792  792   0003D6 3D                  rts ; undefined state - do nothing but return
  793  793                              
  794  794                      turnofft6:
  795  795                              ;changes lights to off
  796  796   0003D7 1D02 58C0           bclr PORTP, LED_MSK_2
  797  797   0003DB 180B 01xx           movb #$01, t6state
             0003DF xx         
  798  798   0003E0 3D                  rts
  799  799                                      
  800  800                              
  801  801                              
  802  802                      t6state0: ; init TASK_1 (not G, not R)
  803  803   0003E1 79xx xx             clr ON2
  804  804   0003E4 1D02 58C0           bclr PORTP, LED_MSK_2 ; ensure that LEDs are off when initialized
  805  805   0003E8 1C02 5AC0           bset DDRP, LED_MSK_2 ; set LED_MSK_1 pins as PORTS outputs
  806  806   0003EC 180B 01xx           movb #$01, t6state ; set next state
             0003F0 xx         
  807  807   0003F1 3D                  rts
  808  808                              
  809  809                      t6state1: ; G, not R
  810  810   0003F2 1C02 5840           bset PORTP, G_LED_2 ; set state1 pattern on LEDs
  811  811   0003F6 F7xx xx             tst DONE_2 ; check TASK_4 done flag
  812  812   0003F9 2705                beq exit_t6s1 ; if not done, return
  813  813   0003FB 180B 02xx           movb #$02, t6state ; otherwise if done, set next state
             0003FF xx         
  814  814                      exit_t6s1:
  815  815   000400 3D                  rts
  816  816                              
  817  817                      t6state2: ; not G, not R
  818  818   000401 1D02 5840           bclr PORTP, G_LED_2 ; set state2 pattern on LEDs
  819  819   000405 F7xx xx             tst DONE_2 ; check TASK_1 done flag
  820  820   000408 2705                beq exit_t6s2 ; if not done, return
  821  821   00040A 180B 03xx           movb #$03, t6state ; otherwise if done, set next state
             00040E xx         
  822  822                      exit_t6s2:
  823  823   00040F 3D                  rts
  824  824                              
  825  825                      t6state3: ; not G, R
  826  826   000410 1C02 5880           bset PORTP, R_LED_2 ; set state3 pattern on LEDs
  827  827   000414 F7xx xx             tst DONE_2 ; check TASK_2 done flag
  828  828   000417 2705                beq exit_t6s3 ; if not done, return
  829  829   000419 180B 04xx           movb #$04, t6state ; otherwise if done, set next state
             00041D xx         
  830  830                      exit_t6s3:
  831  831   00041E 3D                  rts
  832  832                              
  833  833                      t6state4 ; not G, not R
  834  834   00041F 1D02 5880           bclr PORTP, R_LED_2 ; set state4 pattern on LEDs
  835  835   000423 F7xx xx             tst DONE_2 ; check TASK_2 done flag
  836  836   000426 2705                beq exit_t6s4 ; if not done, return
  837  837   000428 180B 05xx           movb #$05, t6state ; otherwise if done, set next state
             00042C xx         
  838  838                      exit_t6s4:
  839  839   00042D 3D                  rts
  840  840                              
  841  841                      t6state5: ; G, R
  842  842   00042E 1C02 58C0           bset PORTP, LED_MSK_2 ; set state5 pattern on LEDs
  843  843   000432 F7xx xx             tst DONE_2 ; check TASK_2 done flag
  844  844   000435 2705                beq exit_t6s5 ; if not done, return
  845  845   000437 180B 06xx           movb #$06, t6state ; otherwise if done, set next state
             00043B xx         

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  846  846                      exit_t6s5:
  847  847   00043C 3D                  rts
  848  848                              
  849  849                      t6state6: ; not G, not R
  850  850   00043D 1D02 58C0           bclr PORTP, LED_MSK_2 ; set state6 pattern on LEDs
  851  851   000441 F7xx xx             tst DONE_2 ; check TASK_2 done flag
  852  852   000444 2705                beq exit_t6s6 ; if not done, return
  853  853   000446 180B 01xx           movb #$01, t6state ; otherwise if done, set next state
             00044A xx         
  854  854                      exit_t6s6:
  855  855   00044B 3D                  rts ; exit TASK_4
  856  856                              
  857  857                      
  858  858                      
  859  859                      
  860  860                      
  861  861                      
  862  862                      
  863  863                      ;------------------TASK 7--------------------------------------------------
  864  864                      ;timing 2
  865  865                      
  866  866   00044C B6xx xx     TASK_7: ldaa t7state ; get current t2state and branch accordingly
  867  867   00044F 2704                beq t7state0
  868  868   000451 43                  deca
  869  869   000452 2710                beq t7state1
  870  870   000454 3D                  rts ; undefined state - do nothing but return
  871  871                              
  872  872                      t7state0: ; initialization for TASK_7
  873  873   000455 1804 xxxx           movw TICKS_2, COUNT_2 ; init COUNT_2
             000459 xxxx       
  874  874   00045B 79xx xx             clr DONE_2 ; init DONE_2 to FALSE
  875  875   00045E 180B 01xx           movb #$01, t7state ; set next state
             000462 xx         
  876  876   000463 3D                  rts
  877  877                              
  878  878                      t7state1: ; Countdown_1
  879  879   000464 B6xx xx             ldaa DONE_2   ;load accumulator A with DONE_2 
  880  880   000467 8101                cmpa #$01     ;check if DONE_2 - 1 = 0 
  881  881   000469 2609                bne t7s1a ; skip reinitialization if DONE_2 is not = 1
  882  882                              
  883  883                              ;reinitialize if DONE_2 = 1 
  884  884                              
  885  885   00046B 1804 xxxx           movw TICKS_2, COUNT_2 ; init COUNT_2
             00046F xxxx       
  886  886   000471 79xx xx             clr DONE_2 ; init DONE_2 to FALSE
  887  887                              
  888  888                             ;after reinitialization, you still decrement
  889  889                              
  890  890   000474 1873 xxxx   t7s1a:  decw COUNT_2    ;decrement COUNT_2
  891  891   000478 2605                bne exit_t7s2   ;if COUNT_2 is not equal to zero, exit 
  892  892   00047A 180B 01xx           movb #$01, DONE_2     ;if COUNT_1 is zero, set DONE_2 to 1
             00047E xx         
  893  893                           
  894  894                              
  895  895                      exit_t7s2:
  896  896   00047F 3D                  rts ; exit TASK_7
  897  897                      
  898  898                      
  899  899                      
  900  900                      
  901  901                      
  902  902                      
  903  903                      ;------------------TASK 8--------------------------------------------------
  904  904                                ;delay

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  905  905                                
  906  906   000480 B6xx xx     TASK_8: ldaa t8state ; get current t3state and branch accordingly
  907  907   000483 2704                beq t8state0
  908  908   000485 43                  deca
  909  909   000486 2707                beq t8state1
  910  910   000488 3D                  rts ; undefined state - do nothing but return
  911  911                      
  912  912                      t8state0: ; initialization for TASK_8
  913  913                              ; no initialization required
  914  914   000489 180B 01xx           movb #$01, t8state ; set next state
             00048D xx         
  915  915   00048E 3D                  rts
  916  916                      
  917  917                      t8state1:
  918  918   00048F 16xx xx             jsr DELAY_1ms
  919  919   000492 3D                  rts ; exit TASK_8
  920  920                              
  921  921                              
  922  922                        
  923  923                      ;/------------------------------------------------------------------------------------\
  924  924                      ;| Subroutines                                                                        |
  925  925                      ;\------------------------------------------------------------------------------------/
  926  926                      ; General purpose subroutines go here
  927  927                      
  928  928                        
  929  929                       ;---------------------------------------------------------------------------------------     
  930  930                               
  931  931                        backspace:
  932  932                       
  933  933   000493 16xx xx            jsr GETADDR                   ;get current position of LCR
  934  934   000496 43                 deca                          ;decrement one
  935  935   000497 16xx xx            jsr SETADDR                   ;set address to new position
  936  936   00049A CExx xx            ldx #BACKSPACE                ;
  937  937   00049D 16xx xx            jsr OUTSTRING                 ;output a blank character
  938  938   0004A0 16xx xx            jsr GETADDR                   ;get current position of LCR
  939  939   0004A3 43                 deca                          ;decrement one
  940  940   0004A4 16xx xx            jsr SETADDR                   ;set address to new position
  941  941   0004A7 73xx xx            dec COUNT                     ;reset the value of count
  942  942                             
  943  943                         
  944  944                        
  945  945                        ;------CONVERSIONS---------------------------------------------------------------------------;
  946  946                      
  947  947                      conversion:
  948  948                      		
  949  949                      		;init here
  950  950   0004AA 1879 xxxx   		clrw RESULT
  951  951   0004AE 79xx xx     		clr TMP
  952  952   0004B1 79xx xx     		clr ERR
  953  953   0004B4 CExx xx     		ldx #BUFFER
  954  954   0004B7 35          		pshy			;pushes registers to stack so that they remain unchanged by the subroutine
  955  955   0004B8 37          		pshb
  956  956   0004B9 39          		pshc
  957  957                      		
  958  958                      		
  959  959                      convloop:
  960  960                      
  961  961                      		;loop goes here
  962  962   0004BA B6xx xx     		ldaa COUNT		;check if COUNT has finished for loop
  963  963   0004BD 272D        		beq loopfin		;branch to exit if COUNT is done
  964  964                      		
  965  965                      		
  966  966   0004BF FDxx xx     		ldy RESULT		;load current value of RESULT into register y for use
  967  967   0004C2 CC00 0A     		ldd #$000A		;load hex 10 into accumulator for use

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  968  968   0004C5 13          		emul			    ;multiply register y and acc d
  969  969   0004C6 18D7        		tsty          ;sets flag for y
  970  970   0004C8 261B        		bne ERR1      ;checks if the multiplication overflowed to y
  971  971   0004CA 7Cxx xx     		std RESULT		;keep the bottom 2 bytes of the emul since we are never dealing with 4 bit nums
  972  972                      		
  973  973                      		
  974  974                      		
  975  975   0004CD B6xx xx     		ldaa TMP		;TMP is used for index addressing
  976  976   0004D0 E6E4        		ldab a,x		;reference the correct digit in the BUFFER using TMP
  977  977   0004D2 C030        		subb #$30		;subtract $30 to get the decimal value of the ascii code
  978  978                      		
  979  979                      		
  980  980   0004D4 87          		clra
  981  981   0004D5 F3xx xx     		addd RESULT		;add RESULT and acc d 
  982  982   0004D8 250B        		bcs ERR1      ;branch if the addition triggers an overflow, causing error 1
  983  983   0004DA 7Cxx xx     		std RESULT		;store addition in RESULT
  984  984   0004DD 72xx xx     		inc TMP		  	;inc TMP so that BUFFER digits are correctly referenced
  985  985   0004E0 73xx xx     		dec COUNT		  ;dec COUNT to track how long the loop has operated for
  986  986   0004E3 20D5        		bra convloop
  987  987                      			
  988  988                      
  989  989                      ERR1:		
  990  990                      
  991  991   0004E5 180B 01xx   		movb #$01, ERR ;set ERR for MAGNITUDE TOO LARGE
             0004E9 xx         
  992  992   0004EA 200A        		bra cnvexit
  993  993                      	
  994  994                      loopfin:
  995  995                      		
  996  996   0004EC FExx xx     		ldx RESULT     ;happens at the end of the loop to check for error 2
  997  997   0004EF 2605        		bne cnvexit	
  998  998                      		
  999  999                      ERR2:
 1000 1000                      
 1001 1001   0004F1 180B 02xx   		movb #$02, ERR  ;set ERR for ZERO MAGNITUDE INAPPROPRIATE
             0004F5 xx         
 1002 1002                      
 1003 1003                      cnvexit:
 1004 1004                      
 1005 1005   0004F6 B6xx xx     		ldaa ERR		;load ERRor into accumulator a
 1006 1006   0004F9 38          		pulc        ;pulls registers from stack to restore them to pre-subroutine states
 1007 1007   0004FA 33          		pulb
 1008 1008   0004FB 31          		puly
 1009 1009   0004FC 3D          		rts         ;return
 1010 1010                              
 1011 1011                      
 1012 1012                      ;-------------------Cooperative Fixed Messaging-------------------------------------------;        
 1013 1013                      
 1014 1014                      PUTCHAR1:    
 1015 1015   0004FD 7Exx xx               stx DPTR
 1016 1016   000500 16xx xx               jsr SETADDR
 1017 1017   000503 79xx xx               clr FIRSTCH
 1018 1018                                
 1019 1019                      PUTCHAR:          
 1020 1020   000506 FExx xx               ldx DPTR
 1021 1021   000509 E600                  ldab 0,x
 1022 1022   00050B 2708                  beq mess_exit
 1023 1023   00050D 1872 xxxx             incw DPTR
 1024 1024   000511 16xx xx               jsr OUTCHAR
 1025 1025   000514 3D                    rts
 1026 1026                      
 1027 1027                      
 1028 1028                      mess_exit:
 1029 1029                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1030 1030   000515 180B 01xx               movb #$01, t3state
             000519 xx         
 1031 1031   00051A 180B 01xx               movb #$01, MSG_NUM
             00051E xx         
 1032 1032   00051F 3D                      rts
 1033 1033                      
 1034 1034                      ;-------------------Cooperative Fixed init message-----------------------
 1035 1035                      
 1036 1036                      ICHAR1: 
 1037 1037   000520 7Exx xx               stx DPTR
 1038 1038   000523 16xx xx               jsr SETADDR
 1039 1039   000526 79xx xx               clr FIRSTCH
 1040 1040                                
 1041 1041                      ICHAR:        
 1042 1042   000529 FExx xx               ldx DPTR
 1043 1043   00052C E600                  ldab 0,x
 1044 1044   00052E 27E5                  beq mess_exit
 1045 1045   000530 1872 xxxx             incw DPTR
 1046 1046   000534 16xx xx               jsr OUTCHAR
 1047 1047   000537 16xx xx               jsr GETADDR
 1048 1048   00053A 8128                  cmpa #$28
 1049 1049   00053C 2701                  beq changeline
 1050 1050   00053E 3D                    rts
 1051 1051                      
 1052 1052                      changeline: 
 1053 1053                      
 1054 1054   00053F 8640                  ldaa #$40
 1055 1055   000541 16xx xx               jsr SETADDR
 1056 1056   000544 3D                    rts
 1057 1057                      
 1058 1058                      
 1059 1059                      ;----------------------DElay----------------------------
 1060 1060                      
 1061 1061                      DELAY_1ms:
 1062 1062   000545 CD05 84             ldy #$0584
 1063 1063                              INNER: ; inside loop
 1064 1064   000548 8D00 00             cpy #0
 1065 1065   00054B 2703                beq EXIT
 1066 1066   00054D 03                  dey
 1067 1067   00054E 20F8                bra INNER
 1068 1068                              EXIT:
 1069 1069   000550 3D                  rts ; exit DELAY_1ms
 1070 1070                              
 1071 1071                              
 1072 1072                              
 1073 1073                      ;-----------------clearbuffer----------------------   
 1074 1074                      
 1075 1075                      clearbuffer:
 1076 1076                      
 1077 1077   000551 CExx xx           ldx #BUFFER
 1078 1078   000554 8600              ldaa #$00
 1079 1079   000556 69E4              clr a, x
 1080 1080   000558 42                inca
 1081 1081   000559 69E4              clr a, x
 1082 1082   00055B 42                inca
 1083 1083   00055C 69E4              clr a, x
 1084 1084   00055E 42                inca
 1085 1085   00055F 69E4              clr a, x
 1086 1086   000561 42                inca
 1087 1087   000562 69E4              clr a, x
 1088 1088   000564 3D                rts
 1089 1089                      
 1090 1090                      
 1091 1091                      ;/------------------------------------------------------------------------------------\

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1092 1092                      ;| ASCII Messages and Constant Data                                                   |
 1093 1093                      ;\------------------------------------------------------------------------------------/
 1094 1094                      ; Any constants can be defined here
 1095 1095                      
 1096 1096   000565 5449 4D45    INITMSG: DC.B 'TIME1 =       <F1> to update LED1 periodTIME2 =       <F2> to update LED1 period', $00
             000569 3120 3D20  
             00056D 2020 2020  
             000571 2020 3C46  
             000575 313E 2074  
             000579 6F20 7570  
             00057D 6461 7465  
             000581 204C 4544  
             000585 3120 7065  
             000589 7269 6F64  
             00058D 5449 4D45  
             000591 3220 3D20  
             000595 2020 2020  
             000599 2020 3C46  
             00059D 323E 2074  
             0005A1 6F20 7570  
             0005A5 6461 7465  
             0005A9 204C 4544  
             0005AD 3120 7065  
             0005B1 7269 6F64  
             0005B5 00         
 1097 1097   0005B6 5449 4D45    TIME1:  DC.B 'TIME1 =     <F1> to update LED1 period', $00
             0005BA 3120 3D20  
             0005BE 2020 2020  
             0005C2 3C46 313E  
             0005C6 2074 6F20  
             0005CA 7570 6461  
             0005CE 7465 204C  
             0005D2 4544 3120  
             0005D6 7065 7269  
             0005DA 6F64 00    
 1098 1098   0005DD 5449 4D45    TIME2:  DC.B 'TIME2 =     <F2> to update LED1 period', $00
             0005E1 3220 3D20  
             0005E5 2020 2020  
             0005E9 3C46 323E  
             0005ED 2074 6F20  
             0005F1 7570 6461  
             0005F5 7465 204C  
             0005F9 4544 3120  
             0005FD 7065 7269  
             000601 6F64 00    
 1099 1099   000604 5449 4D45    NODIG1: DC.B 'TIME1 = NO DIGITS ENTERED             ', $00
             000608 3120 3D20  
             00060C 4E4F 2044  
             000610 4947 4954  
             000614 5320 454E  
             000618 5445 5245  
             00061C 4420 2020  
             000620 2020 2020  
             000624 2020 2020  
             000628 2020 00    
 1100 1100   00062B 5449 4D45    NODIG2: DC.B 'TIME2 = NO DIGITS ENTERED             ', $00
             00062F 3220 3D20  
             000633 4E4F 2044  
             000637 4947 4954  
             00063B 5320 454E  
             00063F 5445 5245  
             000643 4420 2020  
             000647 2020 2020  
             00064B 2020 2020  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             00064F 2020 00    
 1101 1101   000652 5449 4D45    ZMAG1:  DC.B 'TIME1 = ZERO MAGNITUDE INAPPROPRIATE  ', $00
             000656 3120 3D20  
             00065A 5A45 524F  
             00065E 204D 4147  
             000662 4E49 5455  
             000666 4445 2049  
             00066A 4E41 5050  
             00066E 524F 5052  
             000672 4941 5445  
             000676 2020 00    
 1102 1102   000679 5449 4D45    ZMAG2:  DC.B 'TIME2 = ZERO MAGNITUDE INAPPROPRIATE  ', $00
             00067D 3220 3D20  
             000681 5A45 524F  
             000685 204D 4147  
             000689 4E49 5455  
             00068D 4445 2049  
             000691 4E41 5050  
             000695 524F 5052  
             000699 4941 5445  
             00069D 2020 00    
 1103 1103   0006A0 5449 4D45    MAGTL1: DC.B 'TIME1 = MAGNITUDE TOO LARGE           ', $00
             0006A4 3120 3D20  
             0006A8 4D41 474E  
             0006AC 4954 5544  
             0006B0 4520 544F  
             0006B4 4F20 4C41  
             0006B8 5247 4520  
             0006BC 2020 2020  
             0006C0 2020 2020  
             0006C4 2020 00    
 1104 1104   0006C7 5449 4D45    MAGTL2: DC.B 'TIME2 = MAGNITUDE TOO LARGE           ', $00
             0006CB 3220 3D20  
             0006CF 4D41 474E  
             0006D3 4954 5544  
             0006D7 4520 544F  
             0006DB 4F20 4C41  
             0006DF 5247 4520  
             0006E3 2020 2020  
             0006E7 2020 2020  
             0006EB 2020 00    
 1105 1105   0006EE 2000         BACKSPACE: DC.B ' ' , $00 
 1106 1106                       
 1107 1107                       
 1108 1108                      ;/------------------------------------------------------------------------------------\
 1109 1109                      ;| Vectors                                                                            |
 1110 1110                      ;\------------------------------------------------------------------------------------/
 1111 1111                      ; Add interrupt and reset vectors here
 1112 1112                      
 1113 1113                              ORG   $FFFE                    ; reset vector address
 1114 1114  a00FFFE xxxx                DC.W  Entry
 1115 1115                      
