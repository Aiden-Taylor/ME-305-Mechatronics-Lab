
Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
    1    1                      ;**************************************************************************************
    2    2                      ;* Blank Project Main [includes LibV2.2]                                              *
    3    3                      ;**************************************************************************************
    4    4                      ;* Summary:                                                                           *
    5    5                      ;*   -                                                                                *
    6    6                      ;*                                                                                    *
    7    7                      ;* Author: Julia Fay & Aiden Taylor                                                   *
    8    8                      ;*   Cal Poly University                                                              *
    9    9                      ;*   Fall 2023                                                                        *
   10   10                      ;*                                                                                    *
   11   11                      ;* Revision History:                                                                  *
   12   12                      ;*   -                                                                                *
   13   13                      ;*                                                                                    *
   14   14                      ;* ToDo:                                                                              *
   15   15                      ;*   -                                                                                *
   16   16                      ;**************************************************************************************
   17   17                      
   18   18                      ;/------------------------------------------------------------------------------------\
   19   19                      ;| Include all associated files                                                       |
   20   20                      ;\------------------------------------------------------------------------------------/
   21   21                      ; The following are external files to be included during assembly
   22   22                      
   23   23                      
   24   24                      ;/------------------------------------------------------------------------------------\
   25   25                      ;| External Definitions                                                               |
   26   26                      ;\------------------------------------------------------------------------------------/
   27   27                      ; All labels that are referenced by the linker need an external definition
   28   28                      
   29   29                                    XDEF  main
   30   30                      
   31   31                      ;/------------------------------------------------------------------------------------\
   32   32                      ;| External References                                                                |
   33   33                      ;\------------------------------------------------------------------------------------/
   34   34                      ; All labels from other files must have an external reference
   35   35                      
   36   36                                    XREF  ENABLE_MOTOR, DISABLE_MOTOR
   37   37                                    XREF  STARTUP_MOTOR, UPDATE_MOTOR, CURRENT_MOTOR
   38   38                                    XREF  STARTUP_PWM, STARTUP_ATD0, STARTUP_ATD1
   39   39                                    XREF  OUTDACA, OUTDACB
   40   40                                    XREF  STARTUP_ENCODER, READ_ENCODER
   41   41                                    XREF  INITLCD, SETADDR, GETADDR, CURSOR_ON, CURSOR_OFF, DISP_OFF
   42   42                                    XREF  OUTCHAR, OUTCHAR_AT, OUTSTRING, OUTSTRING_AT
   43   43                                    XREF  INITKEY, LKEY_FLG, GETCHAR
   44   44                                    XREF  LCDTEMPLATE, UPDATELCD_L1, UPDATELCD_L2
   45   45                                    XREF  LVREF_BUF, LVACT_BUF, LERR_BUF,LEFF_BUF, LKP_BUF, LKI_BUF
   46   46                                    XREF  Entry, ISR_KEYPAD
   47   47                                  
   48   48                      ;/------------------------------------------------------------------------------------\
   49   49                      ;| Assembler Equates                                                                  |
   50   50                      ;\------------------------------------------------------------------------------------/
   51   51                      ; Constant values can be equated here
   52   52                      
   53   53                      
   54   54                      
   55   55                      ;/------------------------------------------------------------------------------------\
   56   56                      ;| Variables in RAM                                                                   |
   57   57                      ;\------------------------------------------------------------------------------------/
   58   58                      ; The following variables are located in unpaged ram
   59   59                      
   60   60                      DEFAULT_RAM:  SECTION
   61   61                      
   62   62                      ;params for t2 
   63   63                      
   64   64   000000             SELECT_FLG DS.B 1 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
   65   65   000001             COUNT DS.B 1 
   66   66   000002             MM_ERR  DS.B 1
   67   67   000003             NINT DS.W 1
   68   68   000005             WAVE_NUM DS.B 1 
   69   69                      
   70   70                      ;params for t3 
   71   71   000006             KEY_FLG DS.B 1
   72   72   000007             KEY_BUFF DS.B 1
   73   73                      
   74   74                      ;params for t4
   75   75   000008             MSG_NUM DS.B 1
   76   76   000009             LNUM DS.B 1
   77   77                      
   78   78                      ;params for t5
   79   79   00000A             RUN DS.B 1
   80   80   00000B             CINT DS.W 1 
   81   81   00000D             NEWBTI DS.B 1  
   82   82   00000E             WAVEPTR DS.B 1  
   83   83   00000F             CSEG DS.B 1 
   84   84   000010             LSEG DS.B 1  
   85   85   000011             SEGPTR DS.B 1  
   86   86   000012             SEGINC DS.B 1  
   87   87   000013             VALUE DS.B 1 
   88   88   000014             DWAVE DS.B 1 
   89   89   000015             DPRMPT DS.B 1
   90   90   000016             NINTOK DS.B 1 
   91   91                      
   92   92                      ;state vars
   93   93   000017             t1state DS.B 1
   94   94   000018             t2state DS.B 1
   95   95   000019             t3state DS.B 1
   96   96   00001A             t4state DS.B 1
   97   97   00001B             t5state DS.B 1
   98   98   00001C             t6state DS.B 1
   99   99   00001D             t7state DS.B 1
  100  100   00001E             t8state DS.B 1
  101  101                      
  102  102                      ;subroutines ---------
  103  103                      
  104  104                      ;convert
  105  105   00001F             RESULT DS.W 1 
  106  106   000021             BUFFER DS.B 3
  107  107   000024             TMP DS.B 1
  108  108   000025             ERR DS.B 1 
  109  109                      
  110  110                      ;input
  111  111   000026             INPUT DS.B 1
  112  112   000027             DPTR DS.W 1
  113  113   000029             FIRSTCH DS.B 1
  114  114                      
  115  115                      ;display
  116  116   00002A             COUNT_ERR DS.W 1
  117  117   00002C             TICKS_ERR DS.W 1
  118  118                      
  119  119                      ;interrupt 
  120  120          0000 0001   Chan0 EQU $01
  121  121          0000 0040   TIOS  EQU $0040
  122  122          0000 0049   TCTL2 EQU $0049
  123  123          0000 004E   TFLG1 EQU $004E
  124  124          0000 004C   TMSK1 EQU $004C
  125  125          0000 0046   TSCR  EQU $0046
  126  126          0000 0044   TCNTH EQU $0044
  127  127          0000 0050   TC0   EQU $0050
  128  128   00002E             INTERVAL DS.W 1

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  129  129                      
  130  130                      ;/------------------------------------------------------------------------------------\
  131  131                      ;|  Main Program Code                                                                 |
  132  132                      ;\------------------------------------------------------------------------------------/
  133  133                      ; Your code goes here
  134  134                      
  135  135                      MyCode:       SECTION
  136  136                      main:   
  137  137                        
  138  138   000000 79xx xx             clr t1state ; initialize all tasks to state 0
  139  139   000003 79xx xx             clr t2state
  140  140   000006 79xx xx             clr t3state
  141  141   000009 79xx xx             clr t4state
  142  142   00000C 79xx xx             clr t5state 
  143  143                              
  144  144                      top:
  145  145                             
  146  146   00000F 16xx xx             jsr TASK_1  ; execute tasks endlessly
  147  147   000012 16xx xx             jsr TASK_2
  148  148   000015 16xx xx             jsr TASK_3
  149  149   000018 16xx xx             jsr TASK_4
  150  150                              ;jsr TASK_5
  151  151   00001B 20F2                bra top       
  152  152                               
  153  153   00001D 20FE        spin:   bra   spin                     ; endless horizontal loop
  154  154                      
  155  155                      
  156  156                      ;-------------TASK_1 TC0 SETUP ---------------------------------------------------------
  157  157                      
  158  158                      TASK_1:
  159  159                      
  160  160   00001F B6xx xx             ldaa t1state ;get state
  161  161   000022 2703                beq t1s0
  162  162   000024 43                  deca
  163  163   000025 271E                beq t1s1
  164  164                      
  165  165                      t1s0: 
  166  166                      
  167  167                      ;Step 1: Pre-initialization
  168  168                      		   
  169  169   000027 1803 03E8   		   movw #$03E8, INTERVAL ; Determine the number of bus clock counts that corresponds to 0.1 msec.
             00002B xxxx       
  170  170                      		   
  171  171                      ;Step 2: Timer Initialization
  172  172                      		   
  173  173   00002D 4C40 01     		   bset TIOS, Chan0     ; Set timer channel 0 for output compare
  174  174   000030 4C49 01     		   bset TCTL2,Chan0     ; Set timer channel 0 to toggle its output pin
  175  175   000033 4C4E 01     		   bset TFLG1, Chan0    ; Clear timer channel flag by writing a 1 to it 
  176  176   000036 10EF        		   cli                  ; Clear I bit 
  177  177   000038 4C4C 01     		   bset TMSK1, Chan0    ; enable maskable interrupts 
  178  178                      		   
  179  179                      
  180  180   00003B 4C46 A0     		   bset TSCR, %10100000 ; enable timer channel output compare intuerrupts 
  181  181                      		                        ; sets TEN = 1  (enable timer bit)
  182  182                      		                        ; sets TSBCK = 1 (timer stop in background mode) 
  183  183                      
  184  184                      ;Step 3: Generating the first interrupt		   
  185  185                      		  
  186  186   00003E DC44        		   ldd TCNTH            ; read current timer count 
  187  187   000040 F3xx xx     		   addd INTERVAL        ; add interval to count 
  188  188   000043 5C50        		   std TC0              ; load result into TC0
  189  189                      
  190  190                      t1s1:  
  191  191                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  192  192   000045 3D           rts 
  193  193                      
  194  194                      
  195  195                      
  196  196                       ;-------------TASK_2 MASTERMIND ---------------------------------------------------------
  197  197                      
  198  198                       TASK_2: 
  199  199                       
  200  200   000046 B6xx xx             ldaa t2state ;get state
  201  201   000049 271D                beq t2s0
  202  202   00004B 43                  deca
  203  203   00004C 272F                beq t2s1
  204  204   00004E 43                  deca
  205  205   00004F 1827 0082           lbeq t2s2
  206  206   000053 43                  deca  
  207  207   000054 1827 00B4           lbeq t2s3
  208  208   000058 43                  deca 
  209  209   000059 1827 0107           lbeq t2s4 
  210  210   00005D 43                  deca 
  211  211   00005E 1827 0113           lbeq t2s5 
  212  212   000062 43                  deca 
  213  213   000063 1827 0136           lbeq t2s6
  214  214   000067 3D                  rts
  215  215                      
  216  216                      ;__________________________________________________________________________________
  217  217                      
  218  218                      t2s0: ; init TASK_2
  219  219                      
  220  220                      ;clear all of the flags and relevant ITCVs
  221  221                       
  222  222   000068 79xx xx             clr SELECT_FLG 
  223  223   00006B 79xx xx             clr KEY_FLG 
  224  224   00006E 79xx xx             clr COUNT
  225  225   000071 16xx xx             jsr clearbuffer                             ;clear buffer
  226  226   000074 180B 01xx           movb #$01, t2state                          ;set next state
             000078 xx         
  227  227   000079 1820 0149           lbra exit2                                  ;exit
  228  228                              
  229  229                       ;__________________________________________________________________________________
  230  230                             
  231  231                      t2s1: ;hub        
  232  232                              
  233  233   00007D F7xx xx             tst KEY_FLG                                 ;first test if there is a key to be checked
  234  234   000080 1827 0142           lbeq exit2                                  ;if there is no key exit
  235  235                              
  236  236                       ;check if 1-4 have already been pressed for the first time 
  237  237                       
  238  238   000084 B6xx xx             ldaa KEY_BUFF                               ;load accumulator A with the current char
  239  239   000087 F7xx xx             tst SELECT_FLG                              ;test if have already selected a wave 
  240  240   00008A 2614                bne skip_select                             ;skip setting the t1 state if already pressed once 
  241  241                       
  242  242                       ;if 1-4 has not been pushed yet, check if its being pushed for the first time 
  243  243                       
  244  244                       ;load accumulator d with the current ascii hex digit to make sure all arithmetic is correct 
  245  245                             
  246  246   00008C 36                  psha                                        ;push whats in a to the stack 
  247  247   00008D 33                  pulb                                        ;pul what was in a into b 
  248  248   00008E 8600                ldaa #$00                                   ;put zeros in a to make it a positive num
  249  249                              
  250  250   000090 8C00 34             cpd #$34                                    ;check if what in A is 1-4 
  251  251   000093 2E0B                bgt skip_select                             ;if its not 1-4, disregard the input  
  252  252   000095 37                  pshb                                        ;restore the stack 
  253  253   000096 32                  pula  
  254  254   000097 180B 05xx           movb #$05 , t2state                         ;set the state to select  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             00009B xx         
  255  255   00009C 1820 0126           lbra exit2               
  256  256                      
  257  257                      skip_select:
  258  258                       
  259  259                      ;check if its a BS 
  260  260                             
  261  261   0000A0 8108                cmpa #$08                                   ;compare whats in A to BS 
  262  262   0000A2 2609                bne skipBS                                  ;if its not BS, skip settting the state 
  263  263   0000A4 180B 04xx           movb #$04 , t2state                         ;set the state to the appropriate number 
             0000A8 xx         
  264  264   0000A9 1820 0119           lbra exit2                                  ;exit
  265  265                      
  266  266                      skipBS: 
  267  267                      
  268  268                      ;check if its a ENT  
  269  269                      
  270  270   0000AD 810A                cmpa #$0A                                   ;compare whats in A to ENT 
  271  271   0000AF 2609                bne skipENT                                 ;if its not BS, skip settting the state 
  272  272   0000B1 180B 03xx           movb #$03 , t2state                         ;set the state to the appropriate number 
             0000B5 xx         
  273  273   0000B6 1820 010C           lbra exit2                                  ;exit
  274  274                              
  275  275                      skipENT:
  276  276                      
  277  277                      ;check if its a digit
  278  278                       
  279  279   0000BA 36                  psha                                        ;push whats in a to the stack 
  280  280   0000BB 33                  pulb                                        ;pul what was in a into b 
  281  281   0000BC 8600                ldaa #$00                                   ;put zeros in a to make it a positive num
  282  282                              
  283  283   0000BE 8C00 39             cpd #$39                                    ;check if what in A is a number 
  284  284   0000C1 2E0B                bgt skipDIGIT                               ;if its not a number, disregard the input
  285  285   0000C3 37                  pshb                                        ;restore the stack 
  286  286   0000C4 32                  pula
  287  287                               
  288  288   0000C5 180B 02xx           movb #$02 , t2state                         ;set the state to digit handler 
             0000C9 xx         
  289  289   0000CA 1820 00F8           lbra exit2                                  ;exit
  290  290                      
  291  291                      skipDIGIT: 
  292  292                      
  293  293   0000CE 79xx xx             clr KEY_FLG
  294  294   0000D1 1820 00F1           lbra exit2                                  ;exit
  295  295                        
  296  296                      ;__________________________________________________________________________________
  297  297                              
  298  298                      t2s2: ;Digit Handler 
  299  299                      
  300  300                      ;checks if we should proceed with the digit handler state 
  301  301                      
  302  302   0000D5 F6xx xx             ldab COUNT                                  ;load b with count 
  303  303   0000D8 C103                cmpb #$03                                   ;check if count is 3
  304  304   0000DA 2705                beq toomany                                 ;if count is 3 stop taking inputs and leave
  305  305   0000DC F7xx xx             tst SELECT_FLG                              ;test SELECT_FLG 
  306  306   0000DF 260C                bne skip_e                                  ;if not equal to 0, skip exiting 
  307  307                      
  308  308                      toomany:        
  309  309                              
  310  310   0000E1 79xx xx             clr KEY_FLG                                 ;clear keyflag 
  311  311   0000E4 180B 01xx           movb #$01 , t2state                         ;set the state back to 1
             0000E8 xx         
  312  312   0000E9 1820 00D9           lbra exit2                                  ;exit  
  313  313                                                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  314  314                      skip_e:
  315  315                      
  316  316                      ;now proceed with the digit handler
  317  317                         
  318  318   0000ED CDxx xx             ldy #BUFFER                                 ;load index register y with buffer 
  319  319   0000F0 B6xx xx             ldaa COUNT                                  ;load A with the current value of COUNT 
  320  320   0000F3 F6xx xx             ldab KEY_BUFF                               ;load b with KEY_BUFF 
  321  321   0000F6 6BEC                stab a,y                                    ;store the contents of b at the position of COUNT in BUFFER
  322  322                             
  323  323   0000F8 72xx xx             inc COUNT                                   ;increment count 
  324  324   0000FB 79xx xx             clr KEY_FLG                                 ;set key flag to 0 to acknowledge KEYPAD
  325  325   0000FE 180B 01xx           movb #$01 , t2state                         ;set the state back to 1  
             000102 xx         
  326  326   000103 180B 0Bxx           movb #$0B, t4state                          ;set state in display task to echo the char
             000107 xx         
  327  327   000108 1820 00BA           lbra exit2                                  ;exit 
  328  328                      
  329  329                      ;__________________________________________________________________________________
  330  330                              
  331  331                      t2s3: ;ENTER 
  332  332                      
  333  333                               
  334  334                      ;before jsr to conversion, check if any digits have been entered into buffer      
  335  335                             
  336  336   00010C 16xx xx            jsr clrcurs                                 ;turn off the cursor when enter is hit   
  337  337   00010F F7xx xx            tst COUNT                                   ;test the current value of count 
  338  338   000112 2604               bne skip_NO_DIGITS                          ;if the count is not zero, branch 
  339  339   000114 8603               ldaa #$03                                   ;if the count is zero, put an error code into A 
  340  340   000116 200C               bra check_error                             ;branch to the set error state below 
  341  341                      
  342  342                      
  343  343                       skip_NO_DIGITS: 
  344  344                      
  345  345                      ;send to conversion to get a BCD form of the input 
  346  346                          
  347  347   000118 16xx xx            jsr conversion                              ;convert the contents of buffer to binary 
  348  348   00011B 7Exx xx            stx NINT                                    ;store the result of conversion in NINT 
  349  349   00011E 79xx xx            clr COUNT                                   ;set count back to zero 
  350  350   000121 79xx xx            clr BUFFER                                  ;clear the contents of the BUFFER
  351  351                             
  352  352                                  
  353  353                      check_error: 
  354  354                             
  355  355                      ;automatically set the state back to 1 for all cases  
  356  356                      
  357  357   000124 180B 01xx          movb #$01, t2state                          ;set the state back to 1 
             000128 xx         
  358  358                             
  359  359                      ;check for error and set variables and state accordingly so that user has to start over 
  360  360                      
  361  361   000129 8100               cmpa #$00                                   ;check whats in A 
  362  362   00012B 2718               beq skipERROR                               ;check if an error was generated from conversion
  363  363   00012D 180B 06xx          movb #$06, t2state                          ;if there is an error code set the state to the 
             000131 xx         
  364  364                                                                         ;error state
  365  365   000132 7Axx xx            staa MM_ERR                                 ;store the error code of accumulator A into a variable 
  366  366                                                                         ;so it is not affected by other code before it gets to 
  367  367                                                                         ;the error state 
  368  368   000135 79xx xx            clr NINT                                    ;clear NINT 
  369  369   000138 79xx xx            clr KEY_FLG                                 ;clear key flag
  370  370   00013B 16xx xx            jsr clearbuffer
  371  371   00013E 16xx xx            jsr CURSOR_OFF   
  372  372   000141 1820 0081          lbra exit2                                   
  373  373                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  374  374                      skipERROR: 
  375  375                      
  376  376                      ;if there are no errors, clear the select and key flags and buffer and exit     
  377  377                            
  378  378   000145 180B 01xx         movb #$01, RUN 
             000149 xx         
  379  379   00014A 16xx xx           jsr clearbuffer                               ;set run to be true if there are no errors 
  380  380   00014D 16xx xx           jsr CURSOR_OFF 
  381  381   000150 79xx xx           clr KEY_FLG 
  382  382   000153 79xx xx           clr SELECT_FLG  
  383  383   000156 180B 01xx         movb #$01, DWAVE 
             00015A xx         
  384  384   00015B 180B 01xx         movb #$01, NINTOK 
             00015F xx         
  385  385   000160 1820 0062         lbra exit2                                    ;exit
  386  386                      
  387  387                      ;________________________________________________________________________________________
  388  388                      
  389  389                      t2s4: ;BS
  390  390                       
  391  391   000164 180B 03xx          movb #$03 , t4state                         ;set the state in task 4 to the BS state   
             000168 xx         
  392  392   000169 180B 01xx          movb #$01 , t2state                         ;set the state back to 1
             00016D xx         
  393  393   00016E 79xx xx            clr KEY_FLG 
  394  394   000171 1820 0051          lbra exit2                                   ;exit
  395  395                      
  396  396                      ;________________________________________________________________________________________
  397  397                      
  398  398                      t2s5: ;SELECT state 
  399  399                       
  400  400                             
  401  401                             
  402  402   000175 180B 01xx          movb #$01, SELECT_FLG                       ;set the SELECT_FLG to be true
             000179 xx         
  403  403   00017A 79xx xx            clr DWAVE 
  404  404   00017D 79xx xx            clr NINTOK 
  405  405   000180 180B 01xx          movb #$01 , t2state                         ;set the state back to 1 
             000184 xx         
  406  406   000185 79xx xx            clr RUN                                     ;clear run 
  407  407   000188 B6xx xx            ldaa KEY_BUFF                               ;load a with whats in KEY_BUFF 
  408  408   00018B 8030               suba #$30	  	                             ;subtract $30 to get the decimal value of the ascii code
  409  409   00018D 7Axx xx            staa WAVE_NUM                               ;store the wave number 
  410  410                             
  411  411                            ;set the display state in task 4 
  412  412   000190 F6xx xx            ldab WAVE_NUM           ;load wave number into b
  413  413   000193 CB03               addb #$03               ;add 3 to get the corresponding task 4 state
  414  414   000195 7Bxx xx            stab t4state            ;store message number in state 
  415  415                             
  416  416                            ;set state in task 5?
  417  417                            
  418  418                            
  419  419                             
  420  420   000198 79xx xx            clr KEY_FLG                                 ;clear the key flag  
  421  421   00019B 2029               bra exit2                                   ;exit
  422  422                      
  423  423                      
  424  424                       ;not sure where to clear wave_num  
  425  425                       
  426  426                           
  427  427                      ;________________________________________________________________________________________
  428  428                      
  429  429                      t2s6: ;Error state 
  430  430                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  431  431                      
  432  432                      ;checks the error code in accumulator A to set the appropiate fixed 
  433  433                      ;message state to be displayed through task 4 
  434  434                      
  435  435                      
  436  436                      ;now check the error number and set the message number for task 4 
  437  437                       
  438  438   00019D B6xx xx            ldaa MM_ERR                                  ;put the error number back into accumulator a 
  439  439   0001A0 8101               cmpa #01                                     ;check if the error code is mag to large 
  440  440   0001A2 2605               bne skip_toolarge                            ;skip setting the message num
  441  441   0001A4 180B 08xx          movb #$08, MSG_NUM                           ;set the appropiate message num 
             0001A8 xx         
  442  442                      
  443  443                      skip_toolarge: 
  444  444                      
  445  445   0001A9 8102               cmpa #02                                     ;check if the error code is zero magnitude 
  446  446   0001AB 2605               bne skip_zeromag                             ;skip setting the message num
  447  447   0001AD 180B 09xx          movb #$09, MSG_NUM                           ;set the appropiate message num 
             0001B1 xx         
  448  448                      
  449  449                      skip_zeromag: 
  450  450                      
  451  451   0001B2 8103               cmpa #03                                     ;check if the error code is zero digits
  452  452   0001B4 2605               bne skip_zerodigits                          ;skip setting the message num
  453  453   0001B6 180B 0Axx          movb #$0A, MSG_NUM                           ;set the appropiate message num    
             0001BA xx         
  454  454                      
  455  455                      skip_zerodigits: 
  456  456                         
  457  457   0001BB 180B 01xx          movb #$01 , t2state                         ;set the state back to 1
             0001BF xx         
  458  458   0001C0 16xx xx            jsr clearbuffer
  459  459   0001C3 79xx xx            clr KEY_FLG
  460  460                             
  461  461                             
  462  462                      ;might be missing the clearing of some variables here 
  463  463                      
  464  464                      exit2: 
  465  465                       
  466  466   0001C6 3D                 rts                                         
  467  467                      
  468  468                       ;-------------TASK_3 KEYPAD ---------------------------------------------------------
  469  469                      
  470  470                       TASK_3:
  471  471                       
  472  472   0001C7 B6xx xx             ldaa t3state ;get state
  473  473   0001CA 2707                beq t3s0
  474  474   0001CC 43                  deca
  475  475   0001CD 270D                beq t3s1
  476  476   0001CF 43                  deca
  477  477   0001D0 2721                beq t3s2
  478  478   0001D2 3D                  rts
  479  479                      
  480  480                      t3s0:   ;init
  481  481                              
  482  482   0001D3 16xx xx             jsr INITKEY       ;initialize keypad
  483  483   0001D6 180B 01xx           movb #$01, t3state
             0001DA xx         
  484  484   0001DB 3D                  rts
  485  485                              
  486  486                      t3s1:   ;Wait for Key   
  487  487                         
  488  488   0001DC F7xx xx             tst LKEY_FLG             ;check if there is a digit in the buffer 
  489  489   0001DF 271C                beq exit3                ;if no key then exit 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  490  490   0001E1 16xx xx             jsr GETCHAR              ;get the character 
  491  491   0001E4 7Bxx xx             stab KEY_BUFF            ;stores the input char into key buffer
  492  492   0001E7 180B 01xx           movb #$01, KEY_FLG       ;set ITCV keyflag to notifiy MM of key input
             0001EB xx         
  493  493   0001EC 180B 02xx           movb #$02, t3state       ;set the state to state 2 
             0001F0 xx         
  494  494   0001F1 20D3                bra exit2                ;exit
  495  495                              
  496  496                      t3s2:   ;Wait for Acknowledgement 
  497  497                      
  498  498   0001F3 F7xx xx             tst KEY_FLG              ;test the ITCV KEY_FLG 
  499  499   0001F6 2605                bne exit3                ;if it is still 1 then do not change state 
  500  500   0001F8 180B 01xx           movb #$01, t3state       ;if it is 0, set state back to 1         
             0001FC xx         
  501  501                      
  502  502   0001FD 3D          exit3: rts                       ;exit 
  503  503                              
  504  504                              
  505  505                              
  506  506                      ;-------------TASK_4 DISPLAY ---------------------------------------------------------
  507  507                      
  508  508                      
  509  509                      TASK_4:
  510  510                      
  511  511   0001FE B6xx xx             ldaa t4state
  512  512   000201 2736                beq t4s0
  513  513   000203 43                  deca
  514  514   000204 274C                beq t4s1
  515  515   000206 43                  deca
  516  516   000207 1827 0058           lbeq t4s2
  517  517   00020B 43                  deca
  518  518   00020C 1827 0063           lbeq t4s3
  519  519   000210 43                  deca
  520  520   000211 1827 0067           lbeq t4s4
  521  521   000215 43                  deca
  522  522   000216 1827 0070           lbeq t4s5
  523  523   00021A 43                  deca
  524  524   00021B 1827 0079           lbeq t4s6
  525  525   00021F 43                  deca
  526  526   000220 1827 0082           lbeq t4s7
  527  527   000224 43                  deca
  528  528   000225 1827 008B           lbeq t4s8
  529  529   000229 43                  deca
  530  530   00022A 1827 0094           lbeq t4s9
  531  531   00022E 43                  deca
  532  532   00022F 1827 009D           lbeq t4s10
  533  533   000233 43                  deca
  534  534   000234 1827 00A6           lbeq t4s11
  535  535   000238 3D                  rts
  536  536                      ;________________________________________________________________________________________
  537  537                      
  538  538                      t4s0:   ;init    
  539  539                              
  540  540   000239 16xx xx             jsr INITLCD             ;initialize LCD
  541  541   00023C 180B 01xx           movb #$01, FIRSTCH      ;set first char to be true 
             000240 xx         
  542  542   000241 8600                ldaa #$00               ;set LCD position to 0
  543  543   000243 16xx xx             jsr SETADDR             ;set the address 
  544  544   000246 1803 5000           movw #$5000, TICKS_ERR  ;set the ticks error to be ___
             00024A xxxx       
  545  545   00024C 180B 02xx           movb #$02, t4state      ;automatically go to state 2 to display the initial message   
             000250 xx         
  546  546   000251 3D                  rts                     ;exit 
  547  547                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  548  548                      ;________________________________________________________________________________________
  549  549                      t4s1:  ;hub
  550  550                                   
  551  551   000252 180B 01xx           movb #$01, FIRSTCH      ;set first char to be true  
             000256 xx         
  552  552   000257 F6xx xx             ldab MSG_NUM            ;load message number into b 
  553  553   00025A 7Bxx xx             stab t4state            ;store message number in state 
  554  554   00025D 180B 01xx           movb #$01, MSG_NUM      ;reset message num       
             000261 xx         
  555  555   000262 3D                  rts                     ;exit 
  556  556                       
  557  557                      ;________________________________________________________________________________________
  558  558                      t4s2:  ;initial message display 
  559  559                      
  560  560   000263 CExx xx             ldx #TOP
  561  561   000266 8600                ldaa #$00               ;set LCD position to 0
  562  562   000268 F7xx xx             tst FIRSTCH 
  563  563   00026B 1826 0085           lbne char1
  564  564   00026F 16xx xx             jsr PUTCHAR           
  565  565   000272 3D                  rts 
  566  566                        
  567  567                      ;________________________________________________________________________________________
  568  568                      t4s3:   ;backspace 
  569  569                      
  570  570   000273 16xx xx             jsr backspace           ;go to backspace subroutine 
  571  571   000276 180B 01xx           movb #$01, t3state      ;reset to state 1 
             00027A xx         
  572  572   00027B 3D                  rts                     ;exit      
  573  573                              
  574  574                      ;________________________________________________________________________________________
  575  575                      t4s4:   ;saw message (wave #1)
  576  576                      
  577  577   00027C CExx xx             ldx #SAWMSG
  578  578   00027F 8640                ldaa #$40               ;set LCD position to 40
  579  579   000281 F7xx xx             tst FIRSTCH 
  580  580   000284 266E                bne char1
  581  581   000286 16xx xx             jsr PUTCHAR
  582  582   000289 3D                  rts  
  583  583                                
  584  584                       ;________________________________________________________________________________________
  585  585                      t4s5:   ;7-seg message  (wave #2)
  586  586                      
  587  587   00028A CExx xx             ldx #SEG7MSG
  588  588   00028D 8640                ldaa #$40               ;set LCD position to 40
  589  589   00028F F7xx xx             tst FIRSTCH 
  590  590   000292 2660                bne char1
  591  591   000294 16xx xx             jsr PUTCHAR
  592  592   000297 3D                  rts  
  593  593                                
  594  594                      ;________________________________________________________________________________________
  595  595                      t4s6:   ;square message  (wawve #3)
  596  596                      
  597  597   000298 CExx xx             ldx #SQUAREMSG 
  598  598   00029B 8640                ldaa #$40               ;set LCD position to 40
  599  599   00029D F7xx xx             tst FIRSTCH 
  600  600   0002A0 2652                bne char1
  601  601   0002A2 16xx xx             jsr PUTCHAR
  602  602   0002A5 3D                  rts  
  603  603                               
  604  604                      ;________________________________________________________________________________________
  605  605                      t4s7:   ;15-seg message  (wave #4) 
  606  606                      
  607  607   0002A6 CExx xx             ldx #SEG15MSG 
  608  608   0002A9 8640                ldaa #$40               ;set LCD position to 40

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  609  609   0002AB F7xx xx             tst FIRSTCH 
  610  610   0002AE 2644                bne char1
  611  611   0002B0 16xx xx             jsr PUTCHAR
  612  612   0002B3 3D                  rts 
  613  613                      ;________________________________________________________________________________________
  614  614                      t4s8:   ;too large error message
  615  615                      
  616  616                       ;can have only three error message states by storing the previous state in a variable and
  617  617                       ;and setting the task 4 state back to that state 
  618  618                       
  619  619   0002B4 CExx xx             ldx #E1
  620  620   0002B7 8655                ldaa #$55               ;set LCD position to 61
  621  621   0002B9 F7xx xx             tst FIRSTCH 
  622  622   0002BC 2636                bne char1
  623  623   0002BE 16xx xx             jsr PUTCHAR
  624  624   0002C1 3D                  rts 
  625  625                      
  626  626                      ;________________________________________________________________________________________
  627  627                      t4s9:   ;invalid magnitude message
  628  628                              
  629  629   0002C2 CExx xx             ldx #E2
  630  630   0002C5 8655                ldaa #$55               ;set LCD position to 61
  631  631   0002C7 F7xx xx             tst FIRSTCH 
  632  632   0002CA 2628                bne char1
  633  633   0002CC 16xx xx             jsr PUTCHAR
  634  634   0002CF 3D                  rts 
  635  635                      
  636  636                      ;________________________________________________________________________________________
  637  637                      t4s10:  ;no digits entered message
  638  638                      
  639  639   0002D0 CExx xx             ldx #E3
  640  640   0002D3 8655                ldaa #$55               ;set LCD position to 61
  641  641   0002D5 F7xx xx             tst FIRSTCH 
  642  642   0002D8 261A                bne char1
  643  643   0002DA 16xx xx             jsr PUTCHAR
  644  644   0002DD 3D                  rts 
  645  645                      ;________________________________________________________________________________________
  646  646                      t4s11:   ;echo 
  647  647                      
  648  648   0002DE B6xx xx             ldaa COUNT 
  649  649   0002E1 8B5A                adda #$5A
  650  650   0002E3 16xx xx             jsr SETADDR 
  651  651   0002E6 16xx xx             jsr CURSOR_ON 
  652  652   0002E9 F6xx xx             ldab KEY_BUFF           ;load accumulator b with whats in KEY_BUFF 
  653  653   0002EC 16xx xx             jsr OUTCHAR             ;display the inputted digit 
  654  654   0002EF 180B 01xx           movb #$01, t4state      ;reset to state 1
             0002F3 xx         
  655  655                      
  656  656                      char1: 
  657  657                        
  658  658   0002F4 16xx xx             jsr PUTCHAR1      
  659  659                              
  660  660                      ;-------------TASK_5 FUNCTION GENERATOR -----------------------------------------------
  661  661                              
  662  662                      
  663  663                       TASK_5:
  664  664                      
  665  665   0002F7 B6xx xx             ldaa t5state
  666  666   0002FA 2711                beq t5s0
  667  667   0002FC 43                  deca
  668  668   0002FD 2713                beq t5s1
  669  669   0002FF 43                  deca
  670  670   000300 2748                beq t5s2
  671  671   000302 43                  deca

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  672  672   000303 1827 0073           lbeq t5s3
  673  673   000307 43                  deca
  674  674   000308 1827 0079           lbeq t5s4
  675  675   00030C 3D                  rts
  676  676                              
  677  677                      ;________________________________________________________________________________________
  678  678                      
  679  679                      t5s0:   ;init    
  680  680                              
  681  681   00030D 180B 01xx           movb #$01, t5state                   
             000311 xx         
  682  682                      
  683  683                      ;________________________________________________________________________________________
  684  684                      
  685  685                      t5s1:  ;wait for wave 
  686  686                                   
  687  687                      ;set the corrrect wave address  
  688  688                             
  689  689   000312 B6xx xx            ldaa WAVE_NUM 
  690  690   000315 1827 00B5          lbeq exit5 
  691  691   000319 43                 deca 
  692  692   00031A 270A               beq t5w1
  693  693   00031C 43                 deca 
  694  694   00031D 2710               beq t5w2 
  695  695   00031F 43                 deca 
  696  696   000320 2716               beq t5w3 
  697  697   000322 43                 deca
  698  698   000323 271C               beq t5w4 
  699  699   000325 3D                 rts
  700  700                             
  701  701                      t5w1:
  702  702                      
  703  703   000326 CExx xx            ldx #SAWTOOTH
  704  704   000329 180B 02xx          movb #$02, t5state
             00032D xx         
  705  705   00032E 3D                 rts  
  706  706                      
  707  707                      t5w2: 
  708  708                      
  709  709   00032F CExx xx            ldx #SQUARE
  710  710   000332 180B 02xx          movb #$02, t5state
             000336 xx         
  711  711   000337 3D                 rts 
  712  712                            
  713  713                      t5w3: 
  714  714                      
  715  715   000338 CExx xx            ldx #SINE_7
  716  716   00033B 180B 02xx          movb #$02, t5state
             00033F xx         
  717  717   000340 3D                 rts 
  718  718                      
  719  719                      t5w4: 
  720  720                      
  721  721   000341 CExx xx            ldx #SINE_15
  722  722   000344 180B 02xx          movb #$02, t5state
             000348 xx         
  723  723   000349 3D                 rts  
  724  724                            
  725  725                                              
  726  726                       
  727  727                      ;________________________________________________________________________________________
  728  728                      
  729  729                      t5s2:  ;new wave 
  730  730                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  731  731                      
  732  732   00034A F7xx xx             tst DWAVE ; wait for display of wave message
  733  733   00034D 262A                bne t5s2a
  734  734   00034F FExx xx             ldx WAVEPTR ; point to start of data for wave
  735  735   000352 180D 00xx           movb 0,X, CSEG ; get number of wave segments
             000356 xx         
  736  736   000357 1805 01xx           movw 1,X, VALUE ; get initial value for DAC
             00035B xx         
  737  737   00035C 180D 03xx           movb 3,X, LSEG ; load segment length
             000360 xx         
  738  738   000361 1805 04xx           movw 4,X, SEGINC ; load segment increment
             000365 xx         
  739  739   000366 08                  inx ; inc SEGPTR to next segment
  740  740   000367 08                  inx
  741  741   000368 08                  inx
  742  742   000369 08                  inx
  743  743   00036A 08                  inx
  744  744   00036B 08                  inx
  745  745   00036C 7Exx xx             stx SEGPTR ; store incremented SEGPTR for next segment
  746  746   00036F 180B 01xx           movb #$01, DPRMPT ; set flag for display of NINT prompt
             000373 xx         
  747  747   000374 180B 03xx           movb #$03, t5state ; set next state
             000378 xx         
  748  748   000379 3D                  t5s2a: rts
  749  749                      
  750  750                              
  751  751                              
  752  752                      ;________________________________________________________________________________________
  753  753                      
  754  754                      t5s3:  ;wait for NINT        
  755  755                              
  756  756                           ;set run if correct nint
  757  757                           
  758  758   00037A F7xx xx             tst NINTOK
  759  759   00037D 274F                beq exit5 
  760  760   00037F 180B 04xx           movb #$04, t5state 
             000383 xx         
  761  761   000384 3D                  rts 
  762  762                               
  763  763                      ;________________________________________________________________________________________
  764  764                      
  765  765                      t5s4:  ;Display wave  
  766  766                      
  767  767   000385 F7xx xx             tst RUN
  768  768   000388 273B                beq t5s4c ; do not update function generator if RUN=0
  769  769   00038A F7xx xx             tst NEWBTI
  770  770   00038D 273E                beq t5s4e ; do not update function generator if NEWBTI=0
  771  771   00038F 73xx xx             dec LSEG ; decrement segment length counter
  772  772   000392 2626                bne t5s4b ; if not at end, simply update DAC output
  773  773   000394 73xx xx             dec CSEG ; if at end, decrement segment counter
  774  774   000397 260E                bne t5s4a ; if not last segment, skip reinit of wave
  775  775   000399 FExx xx             ldx WAVEPTR ; point to start of data for wave
  776  776   00039C 180D 00xx           movb 0,X, CSEG ; get number of wave segments
             0003A0 xx         
  777  777   0003A1 08                  inx ; inc SEGPTR to start of first segment
  778  778   0003A2 08                  inx
  779  779   0003A3 08                  inx
  780  780   0003A4 7Exx xx             stx SEGPTR ; store incremented SEGPTR
  781  781   0003A7 FExx xx             t5s4a: ldx SEGPTR ; point to start of new segment
  782  782   0003AA 180D 00xx           movb 0,X, LSEG ; initialize segment length counter
             0003AE xx         
  783  783   0003AF 1805 01xx           movw 1,X, SEGINC ; load segment increment
             0003B3 xx         
  784  784   0003B4 08                  inx ; inc SEGPTR to next segment

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  785  785   0003B5 08                  inx
  786  786   0003B6 08                  inx
  787  787   0003B7 7Exx xx             stx SEGPTR ; store incremented SEGPTR
  788  788   0003BA FCxx xx             t5s4b: ldd VALUE ; get current DAC input value
  789  789   0003BD F3xx xx             addd SEGINC ; add SEGINC to current DAC input value
  790  790   0003C0 7Cxx xx             std VALUE ; store incremented DAC input value
  791  791   0003C3 2005                bra t5s4d
  792  792   0003C5 180B 01xx           t5s4c: movb #$01, t5state ; set next state
             0003C9 xx         
  793  793   0003CA 79xx xx             t5s4d: clr NEWBTI
  794  794   0003CD 3D                  t5s4e: rts
  795  795                       
  796  796                       exit5: 
  797  797                       
  798  798   0003CE 3D                  rts 
  799  799                      
  800  800                      ;/------------------------------------------------------------------------------------\
  801  801                      ;| Subroutines                                                                        |
  802  802                      ;\------------------------------------------------------------------------------------/
  803  803                      ; General purpose subroutines go here
  804  804                      
  805  805                      ;------ISUBROUT-----------------------------------------------------------------------;
  806  806                      
  807  807                      isubrout:
  808  808                      
  809  809                      ;first check run is one 
  810  810                      
  811  811   0003CF F7xx xx            tst RUN 
  812  812   0003D2 271B               beq NXT_INT
  813  813                      
  814  814                      ;next check if CINT is zero 
  815  815                              
  816  816   0003D4 F7xx xx            tst CINT 
  817  817   0003D7 2705               beq NEW_CINT 
  818  818   0003D9 73xx xx            dec CINT  
  819  819   0003DC 2011               bra NXT_INT 
  820  820                              
  821  821                      NEW_CINT: 
  822  822                      
  823  823   0003DE B6xx xx            ldaa NINT 
  824  824   0003E1 7Axx xx            staa CINT 
  825  825   0003E4 180B 01xx          movb #$01, NEWBTI 
             0003E8 xx         
  826  826   0003E9 FCxx xx            ldd VALUE 
  827  827   0003EC 16xx xx            jsr OUTDACA 
  828  828                             
  829  829                      NXT_INT:
  830  830                              
  831  831   0003EF DC50                ldd TC0                ; read current timer count  
  832  832   0003F1 F3xx xx             addd INTERVAL          ; add interval 
  833  833   0003F4 5C50                std TC0                ; store result  
  834  834   0003F6 4C4E FF             bset TFLG1, %11111111  ; clear timer channel 0 flag by writing a 1 to it
  835  835                             
  836  836                              
  837  837   0003F9 0B                  rti
  838  838                      
  839  839                      ;------BACKSPACE----------------------------------------------------------------------;   
  840  840                               
  841  841                      backspace:
  842  842                        
  843  843   0003FA F7xx xx             tst COUNT                     ;test if count is zero
  844  844   0003FD 2717                beq bkspexit                  ;if the count is zero, dont allow backspace to occur 
  845  845   0003FF 16xx xx             jsr GETADDR                   ;get current position of LCR
  846  846   000402 43                  deca                          ;decrement one

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  847  847   000403 16xx xx             jsr SETADDR                   ;set address to new position
  848  848   000406 CExx xx             ldx #BACKSPACE                ;load a blank space 
  849  849   000409 16xx xx             jsr OUTSTRING                 ;output a blank space
  850  850   00040C 16xx xx             jsr GETADDR                   ;get current position of LCR
  851  851   00040F 43                  deca                          ;decrement one
  852  852   000410 16xx xx             jsr SETADDR                   ;set address to new position
  853  853   000413 73xx xx             dec COUNT                     ;reset the value of count
  854  854                        
  855  855                      bkspexit:
  856  856                      
  857  857   000416 3D                 rts
  858  858                             
  859  859                      ;------CONVERSION---------------------------------------------------------------------------;
  860  860                      
  861  861                      conversion:
  862  862                      		
  863  863                      ;clear all variables 
  864  864                      
  865  865   000417 1879 xxxx   	    	clrw RESULT
  866  866   00041B 79xx xx     	    	clr TMP
  867  867   00041E 79xx xx     	     	clr ERR
  868  868   000421 CExx xx     	    	ldx #BUFFER
  869  869                      	    	
  870  870                      ;pushes registers to stack so that they remain unchanged by the subroutine 
  871  871                      	  
  872  872   000424 35            	   	pshy		
  873  873   000425 37            	  	pshb
  874  874   000426 39            	  	pshc
  875  875                      		
  876  876                      		
  877  877                      convloop:
  878  878                      
  879  879                      	
  880  880   000427 B6xx xx     	    	ldaa COUNT		;check if COUNT has finished for loop
  881  881   00042A 272A        	    	beq loopfin		;branch to exit if COUNT is done
  882  882                      		
  883  883                      		
  884  884   00042C FDxx xx     	     	ldy RESULT		;load current value of RESULT into register y for use
  885  885   00042F CC00 0A     	    	ldd #$000A		;load hex 10 into accumulator for use
  886  886   000432 13              		emul			    ;multiply register y and acc d
  887  887   000433 7Cxx xx     	    	std RESULT		;keep the bottom 2 bytes of the emul since we are never dealing with 4 bit nums
  888  888                      		
  889  889                      		
  890  890                      		
  891  891   000436 B6xx xx     	    	ldaa TMP	  	;TMP is used for index addressing
  892  892   000439 E6E4        	    	ldab a,x	  	;reference the correct digit in the BUFFER using TMP
  893  893   00043B C030        	    	subb #$30	  	;subtract $30 to get the decimal value of the ascii code
  894  894                      	    	
  895  895                      		
  896  896   00043D 87          	    	clra
  897  897   00043E F3xx xx     	    	addd RESULT		;add RESULT and acc d 
  898  898   000441 97          	    	tsta          ;test if a is zero 
  899  899   000442 260B        	    	bne ERR1      ;if it is not zero, it has "overflowed"
  900  900   000444 7Cxx xx     	    	std RESULT		;store addition in RESULT
  901  901   000447 72xx xx     	    	inc TMP		  	;inc TMP so that BUFFER digits are correctly referenced
  902  902   00044A 73xx xx     	    	dec COUNT		  ;dec COUNT to track how long the loop has operated for
  903  903   00044D 20D8        	    	bra convloop
  904  904                      			
  905  905                      
  906  906                      ERR1:		
  907  907                      
  908  908   00044F 180B 01xx   	    	movb #$01, ERR ;set ERR for MAGNITUDE TOO LARGE
             000453 xx         
  909  909   000454 200A            		bra cnvexit

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  910  910                      	
  911  911                      loopfin:
  912  912                      		
  913  913   000456 FExx xx     	    	ldx RESULT     ;load x with result 
  914  914   000459 2605        	    	bne cnvexit	   ;if the result is zero, fall through and set error state
  915  915                      		
  916  916                      ERR2:
  917  917                      
  918  918   00045B 180B 02xx   	    	movb #$02, ERR  ;set ERR for ZERO MAGNITUDE INAPPROPRIATE
             00045F xx         
  919  919                      
  920  920                      cnvexit:
  921  921                      
  922  922   000460 B6xx xx     	    	ldaa ERR		;load ERRor into accumulator a
  923  923                      	    	
  924  924                      ;pulls registers from stack to restore them to pre-subroutine states
  925  925                      
  926  926   000463 38          	    	pulc        
  927  927   000464 33          	    	pulb
  928  928   000465 31              		puly
  929  929   000466 3D              		rts         ;return
  930  930                                     
  931  931                      ;-------------------Cooperative Fixed Messaging-------------------------------------------;        
  932  932                      
  933  933                      PUTCHAR1:
  934  934                          
  935  935   000467 7Exx xx             stx DPTR                      ;store the contents of x into DPTR 
  936  936   00046A 16xx xx             jsr SETADDR                   ;set the address on the LCD 
  937  937   00046D 79xx xx             clr FIRSTCH                   ;clear first char  
  938  938   000470 1804 xxxx           movw TICKS_ERR, COUNT_ERR     ;initialize the amount of ticks an error will disply for
             000474 xxxx       
  939  939                                
  940  940                      PUTCHAR:  
  941  941                              
  942  942   000476 FExx xx             ldx DPTR                      ;put whats in DPTR into x 
  943  943   000479 E600                ldab 0,x                      ;input the current char to be displayed in b 
  944  944   00047B 2716                beq ERR_DELAY 
  945  945   00047D 1872 xxxx           incw DPTR                     ;increment the position of DPTR to get next character 
  946  946   000481 16xx xx             jsr OUTCHAR                   ;output the current charater 
  947  947   000484 3D                  rts                           ;exit 
  948  948                              
  949  949                      mess_exit:
  950  950                      
  951  951   000485 180B 01xx           movb #$01, t4state
             000489 xx         
  952  952   00048A 180B 01xx           movb #$01, MSG_NUM
             00048E xx         
  953  953   00048F 16xx xx             jsr clrcurs
  954  954   000492 3D                  rts
  955  955                              
  956  956                              
  957  957                      ERR_DELAY:
  958  958                             
  959  959   000493 16xx xx             jsr clrcurs
  960  960   000496 B6xx xx             ldaa t4state
  961  961   000499 8107                cmpa #$07
  962  962   00049B 2FE8                ble mess_exit
  963  963                            
  964  964   00049D F7xx xx             tst COUNT_ERR
  965  965   0004A0 2705                beq err_exit
  966  966   0004A2 1873 xxxx           decw COUNT_ERR
  967  967   0004A6 3D                  rts
  968  968                                  
  969  969                      err_exit:

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  970  970                              
  971  971   0004A7 F6xx xx             ldab WAVE_NUM           ;load wave number into b
  972  972   0004AA CB03                addb #$03               ;add 3 to get the corresponding task 4 state
  973  973   0004AC 7Bxx xx             stab t4state            ;store message number in state
  974  974   0004AF 180B 01xx           movb #$01, FIRSTCH
             0004B3 xx         
  975  975   0004B4 3D                  rts
  976  976                                  
  977  977                      
  978  978                      clrcurs: ;resets the cursor address 
  979  979                      
  980  980   0004B5 36                  psha
  981  981   0004B6 8630                ldaa #$30
  982  982   0004B8 16xx xx             jsr SETADDR
  983  983   0004BB 32                  pula
  984  984   0004BC 3D                  rts
  985  985                              
  986  986                              
  987  987                      ;-----------------clearbuffer----------------------   
  988  988                      
  989  989                      clearbuffer:
  990  990                      
  991  991                      ;reset the buffer so it is full of zeros 
  992  992                      
  993  993   0004BD CExx xx             ldx #BUFFER
  994  994   0004C0 8600                ldaa #$00
  995  995   0004C2 69E4                clr a, x
  996  996   0004C4 42                  inca
  997  997   0004C5 69E4                clr a, x
  998  998   0004C7 42                  inca
  999  999   0004C8 69E4                clr a, x
 1000 1000   0004CA 3D                  rts
 1001 1001                             
 1002 1002                      
 1003 1003                      ;/------------------------------------------------------------------------------------\
 1004 1004                      ;| ASCII Messages and Constant Data                                                   |
 1005 1005                      ;\------------------------------------------------------------------------------------/
 1006 1006                      ; Any constants can be defined here
 1007 1007                      
 1008 1008   0004CB 313A 2053   TOP:  		DC.B '1: SAW, 2: SINE-7, 3: SQUARE, 4: SINE-15', $00	;message for the top of the screen
             0004CF 4157 2C20  
             0004D3 323A 2053  
             0004D7 494E 452D  
             0004DB 372C 2033  
             0004DF 3A20 5351  
             0004E3 5541 5245  
             0004E7 2C20 343A  
             0004EB 2053 494E  
             0004EF 452D 3135  
             0004F3 00         
 1009 1009                      
 1010 1010   0004F4 5341 5754   SAWMSG:  		DC.B 'SAWTOOTH WAVE        NINT:     [1-->255]', $00	;message for when SAWTOOTH is chosen
             0004F8 4F4F 5448  
             0004FC 2057 4156  
             000500 4520 2020  
             000504 2020 2020  
             000508 204E 494E  
             00050C 543A 2020  
             000510 2020 205B  
             000514 312D 2D3E  
             000518 3235 355D  
             00051C 00         
 1011 1011   00051D 5341 5754   SAWE1: 		DC.B 'SAWTOOTH WAVE        MAGNITUDE TOO LARGE', $00	;message for when SAWTOOTH MAGNITUDE TOO LARGE
             000521 4F4F 5448  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000525 2057 4156  
             000529 4520 2020  
             00052D 2020 2020  
             000531 204D 4147  
             000535 4E49 5455  
             000539 4445 2054  
             00053D 4F4F 204C  
             000541 4152 4745  
             000545 00         
 1012 1012   000546 5341 5754   SAWE2:  	DC.B 'SAWTOOTH WAVE        INVALID MAGNITUDE  ', $00	;message for when SAWTOOTH INVALID MAGNITUDE  
             00054A 4F4F 5448  
             00054E 2057 4156  
             000552 4520 2020  
             000556 2020 2020  
             00055A 2049 4E56  
             00055E 414C 4944  
             000562 204D 4147  
             000566 4E49 5455  
             00056A 4445 2020  
             00056E 00         
 1013 1013   00056F 5341 5754   SAWE3:  	DC.B 'SAWTOOTH WAVE        NO DIGITS ENTERED  ', $00	;message for when SAWTOOTH NO DIGITS ENTERED  
             000573 4F4F 5448  
             000577 2057 4156  
             00057B 4520 2020  
             00057F 2020 2020  
             000583 204E 4F20  
             000587 4449 4749  
             00058B 5453 2045  
             00058F 4E54 4552  
             000593 4544 2020  
             000597 00         
 1014 1014                      
 1015 1015   000598 372D 5345   SEG7MSG:	  	DC.B '7-SEGMENT SINE WAVE  NINT:     [1-->255]', $00	;message for when 7 Seg sine is chosen
             00059C 474D 454E  
             0005A0 5420 5349  
             0005A4 4E45 2057  
             0005A8 4156 4520  
             0005AC 204E 494E  
             0005B0 543A 2020  
             0005B4 2020 205B  
             0005B8 312D 2D3E  
             0005BC 3235 355D  
             0005C0 00         
 1016 1016   0005C1 372D 5345   SEG7E1:		DC.B '7-SEGMENT SINE WAVE  MAGNITUDE TOO LARGE', $00	;message for when 7 Seg sine MAGNITUDE TOO LARGE
             0005C5 474D 454E  
             0005C9 5420 5349  
             0005CD 4E45 2057  
             0005D1 4156 4520  
             0005D5 204D 4147  
             0005D9 4E49 5455  
             0005DD 4445 2054  
             0005E1 4F4F 204C  
             0005E5 4152 4745  
             0005E9 00         
 1017 1017   0005EA 372D 5345   SEG7E2:		DC.B '7-SEGMENT SINE WAVE  INVALID MAGNITUDE  ', $00	;message for when 7 Seg sine INVALID MAGNITUDE  
             0005EE 474D 454E  
             0005F2 5420 5349  
             0005F6 4E45 2057  
             0005FA 4156 4520  
             0005FE 2049 4E56  
             000602 414C 4944  
             000606 204D 4147  
             00060A 4E49 5455  
             00060E 4445 2020  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000612 00         
 1018 1018   000613 372D 5345   SEG7E3:		DC.B '7-SEGMENT SINE WAVE  NO DIGITS ENTERED  ', $00	;message for when 7 Seg sine NO DIGITS ENTERED  
             000617 474D 454E  
             00061B 5420 5349  
             00061F 4E45 2057  
             000623 4156 4520  
             000627 204E 4F20  
             00062B 4449 4749  
             00062F 5453 2045  
             000633 4E54 4552  
             000637 4544 2020  
             00063B 00         
 1019 1019                      
 1020 1020   00063C 5351 5541   SQUAREMSG:		DC.B 'SQUARE WAVE          NINT:     [1-->255]', $00	;message for when SQUARE is chosen
             000640 5245 2057  
             000644 4156 4520  
             000648 2020 2020  
             00064C 2020 2020  
             000650 204E 494E  
             000654 543A 2020  
             000658 2020 205B  
             00065C 312D 2D3E  
             000660 3235 355D  
             000664 00         
 1021 1021   000665 5351 5541   SQUAREE1:	DC.B 'SQUARE WAVE          MAGNITUDE TOO LARGE', $00	;message for when SQUARE MAGNITUDE TOO LARGE
             000669 5245 2057  
             00066D 4156 4520  
             000671 2020 2020  
             000675 2020 2020  
             000679 204D 4147  
             00067D 4E49 5455  
             000681 4445 2054  
             000685 4F4F 204C  
             000689 4152 4745  
             00068D 00         
 1022 1022   00068E 5351 5541   SQUAREE2:	DC.B 'SQUARE WAVE          INVALID MAGNITUDE  ', $00	;message for when SQUARE INVALID MAGNITUDE  
             000692 5245 2057  
             000696 4156 4520  
             00069A 2020 2020  
             00069E 2020 2020  
             0006A2 2049 4E56  
             0006A6 414C 4944  
             0006AA 204D 4147  
             0006AE 4E49 5455  
             0006B2 4445 2020  
             0006B6 00         
 1023 1023   0006B7 5351 5541   SQUAREE3:	DC.B 'SQUARE WAVE          NO DIGITS ENTERED  ', $00	;message for when SQUARE is chosen
             0006BB 5245 2057  
             0006BF 4156 4520  
             0006C3 2020 2020  
             0006C7 2020 2020  
             0006CB 204E 4F20  
             0006CF 4449 4749  
             0006D3 5453 2045  
             0006D7 4E54 4552  
             0006DB 4544 2020  
             0006DF 00         
 1024 1024                      
 1025 1025   0006E0 3135 2D53   SEG15MSG:		DC.B '15-SEGMENT SINE WAVE NINT:     [1-->255]', $00	;message for when 15 seg sine is chosen
             0006E4 4547 4D45  
             0006E8 4E54 2053  
             0006EC 494E 4520  
             0006F0 5741 5645  
             0006F4 204E 494E  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             0006F8 543A 2020  
             0006FC 2020 205B  
             000700 312D 2D3E  
             000704 3235 355D  
             000708 00         
 1026 1026   000709 3135 2D53   SEG15E1:	DC.B '15-SEGMENT SINE WAVE MAGNITUDE TOO LARGE', $00	;message for when 15 seg sine MAGNITUDE TOO LARGE
             00070D 4547 4D45  
             000711 4E54 2053  
             000715 494E 4520  
             000719 5741 5645  
             00071D 204D 4147  
             000721 4E49 5455  
             000725 4445 2054  
             000729 4F4F 204C  
             00072D 4152 4745  
             000731 00         
 1027 1027   000732 3135 2D53   SEG15E2:	DC.B '15-SEGMENT SINE WAVE INVALID MAGNITUDE  ', $00	;message for when 15 seg sine INVALID MAGNITUDE  
             000736 4547 4D45  
             00073A 4E54 2053  
             00073E 494E 4520  
             000742 5741 5645  
             000746 2049 4E56  
             00074A 414C 4944  
             00074E 204D 4147  
             000752 4E49 5455  
             000756 4445 2020  
             00075A 00         
 1028 1028   00075B 3135 2D53   SEG15E3:	DC.B '15-SEGMENT SINE WAVE NO DIGITS ENTERED  ', $00	;message for when 15 seg sine NO DIGITS ENTERED
             00075F 4547 4D45  
             000763 4E54 2053  
             000767 494E 4520  
             00076B 5741 5645  
             00076F 204E 4F20  
             000773 4449 4749  
             000777 5453 2045  
             00077B 4E54 4552  
             00077F 4544 2020  
             000783 00         
 1029 1029                      
 1030 1030   000784 2000        BACKSPACE: DC.B ' ' , $00 
 1031 1031   000786 4D41 474E   E1:	DC.B 'MAGNITUDE TOO LARGE', $00	;message for when MAGNITUDE TOO LARGE
             00078A 4954 5544  
             00078E 4520 544F  
             000792 4F20 4C41  
             000796 5247 4500  
 1032 1032   00079A 494E 5641   E2:	DC.B 'INVALID MAGNITUDE  ', $00	;message for when INVALID MAGNITUDE  
             00079E 4C49 4420  
             0007A2 4D41 474E  
             0007A6 4954 5544  
             0007AA 4520 2000  
 1033 1033   0007AE 4E4F 2044   E3:	DC.B 'NO DIGITS ENTERED  ', $00	;message for when NO DIGITS ENTERED    
             0007B2 4947 4954  
             0007B6 5320 454E  
             0007BA 5445 5245  
             0007BE 4420 2000  
 1034 1034                      
 1035 1035                      SAWTOOTH:
 1036 1036   0007C2 02          		DC.B 2 		; number of segments for SAWTOOTH
 1037 1037   0007C3 0000        		DC.W 0	 	; initial DAC input value
 1038 1038   0007C5 13          		DC.B 19	 	; length for segment_1
 1039 1039   0007C6 00AC        		DC.W 172 	; increment for segment_1
 1040 1040   0007C8 01          		DC.B 1	 	; length for segment_2
 1041 1041   0007C9 F33C        		DC.W -3268 	; increment for segment_2
 1042 1042                      		

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1043 1043                      SQUARE:
 1044 1044   0007CB 04          		DC.B 4 		; number of segments for TRIANGLE
 1045 1045   0007CC 0000        		DC.W 0	 	; initial DAC input value
 1046 1046   0007CE 09          		DC.B 9	 	; length for segment_1
 1047 1047   0007CF 0000        		DC.W 0 		; increment for segment_1
 1048 1048   0007D1 01          		DC.B 1	 	; length for segment_2
 1049 1049   0007D2 0CC4        		DC.W 3268 	; increment for segment_2
 1050 1050   0007D4 09          		DC.B 9	 	; length for segment_3
 1051 1051   0007D5 0000        		DC.W 0	 	; increment for segment_3
 1052 1052   0007D7 09          		DC.B 9	 	; length for segment_4
 1053 1053   0007D8 F33C        		DC.W -3268 	; increment for segment_4
 1054 1054                      		
 1055 1055                      SINE_7:
 1056 1056   0007DA 07          		DC.B 7		; number of segments for SINE_7
 1057 1057   0007DB 0800        		DC.W 2048	; initial DAC input value
 1058 1058   0007DD 19          		DC.B 25		; length for segment_1
 1059 1059   0007DE 0021        		DC.W 33		; increment for segment_1
 1060 1060   0007E0 32          		DC.B 50		; length for segment_2
 1061 1061   0007E1 0008        		DC.W 8		; increment for segment_2
 1062 1062   0007E3 32          		DC.B 50		; length for segment_3
 1063 1063   0007E4 FFF8        		DC.W -8		; increment for segment_3
 1064 1064   0007E6 32          		DC.B 50		; length for segment_4
 1065 1065   0007E7 FFDF        		DC.W -33	; increment for segment_4
 1066 1066   0007E9 32          		DC.B 50		; length for segment_5
 1067 1067   0007EA FFF8        		DC.W -8		; increment for segment_5
 1068 1068   0007EC 32          		DC.B 50		; length for segment_6
 1069 1069   0007ED 0008        		DC.W 8		; increment for segment_6
 1070 1070   0007EF 0021        		DC.W 33		; length for segment_7
 1071 1071   0007F1 19          		DC.B 25		; increment for segment_7
 1072 1072                      		
 1073 1073                      SINE_15:
 1074 1074   0007F2 0F          		DC.B 15 	; number of segments for SINE
 1075 1075   0007F3 0800        		DC.W 2048 	; initial DAC input value
 1076 1076   0007F5 0A          		DC.B 10		; length for segment_1
 1077 1077   0007F6 0029        		DC.W 41 	; increment for segment_1
 1078 1078   0007F8 15          		DC.B 21 	; length for segment_2
 1079 1079   0007F9 0025        		DC.W 37 	; increment for segment_2
 1080 1080   0007FB 15          		DC.B 21 	; length for segment_3
 1081 1081   0007FC 0019        		DC.W 25 	; increment for segment_3
 1082 1082   0007FE 15          		DC.B 21 	; length for segment_4
 1083 1083   0007FF 0009        		DC.W 9 		; increment for segment_4
 1084 1084   000801 15          		DC.B 21 	; length for segment_5
 1085 1085   000802 FFF7        		DC.W -9 	; increment for segment_5
 1086 1086   000804 15          		DC.B 21 	; length for segment_6
 1087 1087   000805 FFE7        		DC.W -25 	; increment for segment_6
 1088 1088   000807 15          		DC.B 21 	; length for segment_7
 1089 1089   000808 FFDB        		DC.W -37 	; increment for segment_7
 1090 1090   00080A 14          		DC.B 20 	; length for segment_8
 1091 1091   00080B FFD7        		DC.W -41 	; increment for segment_8
 1092 1092   00080D 15          		DC.B 21 	; length for segment_9
 1093 1093   00080E FFDB        		DC.W -37 	; increment for segment_9
 1094 1094   000810 15          		DC.B 21 	; length for segment_10
 1095 1095   000811 FFE7        		DC.W -25 	; increment for segment_10
 1096 1096   000813 15          		DC.B 21 	; length for segment_11
 1097 1097   000814 FFF7        		DC.W -9 	; increment for segment_11
 1098 1098   000816 15          		DC.B 21 	; length for segment_12
 1099 1099   000817 0009        		DC.W 9 		; increment for segment_12
 1100 1100   000819 15          		DC.B 21 	; length for segment_13
 1101 1101   00081A 0019        		DC.W 25 	; increment for segment_13
 1102 1102   00081C 15          		DC.B 21 	; length for segment_14
 1103 1103   00081D 0025        		DC.W 37 	; increment for segment_14
 1104 1104   00081F 0A          		DC.B 10 	; length for segment_15
 1105 1105   000820 0029        		DC.W 41 	; increment for segment_15
 1106 1106                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1107 1107                      ;/------------------------------------------------------------------------------------\
 1108 1108                      ;| Vectors                                                                            |
 1109 1109                      ;\------------------------------------------------------------------------------------/
 1110 1110                      ; Add interrupt and reset vectors here
 1111 1111                      
 1112 1112                              ORG   $FFFE                    ; reset vector address
 1113 1113  a00FFFE xxxx                DC.W  Entry
 1114 1114                      
 1115 1115                              ORG   $FFEE                    ; chan 0 vector address 
 1116 1116  a00FFEE xxxx                DC.W  isubrout 
