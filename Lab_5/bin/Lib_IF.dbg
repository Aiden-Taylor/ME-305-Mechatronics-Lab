;/-------------------------------------------------------------------------------------------------\                                                                                              
;| Lab 5 (EXTRA) Subroutines - for Library Files ME305LIBV3.0.lib                                                                            |
;|-------------------------------------------------------------------------------------------------|
;| HARDWARE DESCRIPTION                                                                            |
;| Manufacturer:                                                                                   |
;| Model Number:                                                                                   |
;| Summary:                                                                                        |
;| Pins Used:                                                                                      |
;|                                                                                                 |
;| SUBROUTINE DESCRIPTION                                                                          |
;|                                                                                                 |  
;\-------------------------------------------------------------------------------------------------/ 
;

            
			XDEF  V_act_DISP, ERR_DISP, EFF_DISP, INTERVAL, Kscale
			XDEF  IFENTRY
			
            XREF  Theta_OLD, RUN, CL, V_ref, KP, KI, UPDATE_FLG1
         
                    
            XREF  ENABLE_MOTOR, DISABLE_MOTOR
            XREF  STARTUP_MOTOR, UPDATE_MOTOR, CURRENT_MOTOR 
            XREF  STARTUP_PWM, STARTUP_ATD0, STARTUP_ATD1   
            XREF  OUTDACA, OUTDACB
            XREF  STARTUP_ENCODER, READ_ENCODER
            XREF  DELAY_MILLI, DELAY_MICRO
            XREF  INITLCD, SETADDR, GETADDR, CURSOR_ON, DISP_OFF
            XREF  OUTCHAR, OUTCHAR_AT, OUTSTRING, OUTSTRING_AT
            XREF  INITKEY, LKEY_FLG, GETCHAR
            XREF  LCDTEMPLATE, UPDATELCD_L1, UPDATELCD_L2
            XREF  LVREF_BUF, LVACT_BUF, LERR_BUF,LEFF_BUF, LKP_BUF, LKI_BUF
            XREF  Entry, ISR_KEYPAD

LIBRARY_RAM: SECTION  

V_entry:      DS.B  1                  ; Boolean for entering V_ref
KP_entry:     DS.B  1                  ; Boolean for working on KP 
KI_entry:     DS.B  1                  ; Boolean for working on KI 
NEG_FLG:      DS.B  1                  ; Boolean indicating '-' sign entered
SIGN_FLG:     DS.B  1                  ; Boolean indicating sign entered

;RUN:          DS.B  1                  ; Boolean indicating controller is running
;CL:           DS.B  1                  ; Boolean for closed-loop active
DISP_ON:      DS.B  1                  ; Boolean for display update active

;V_ref:        DS.W  1                  ; reference velocity
V_act:        DS.W  1                  ; actual velocity
;Theta_NEW:    DS.W  1                  ; new encoder position
;Theta_OLD:    DS.W  1                  ; previous encoder reading
;KP:           DS.W  1                  ; proportional gain
;KI:           DS.W  1                  ; integral gain
Kscale:        DS.W  1                  ; scale factor to preserve pre-2016 compatibility
ERR:          DS.W  1                  ; error, where ERR = V_ref - V_act
EFF:          DS.W  1                  ; effort
ESUM:         DS.W  1                  ; accumulated error (area under err vs. t curve)

V_act_DISP:   DS.W  1                  ; actual velocity display value
ERR_DISP:     DS.W  1                  ; error display value
EFF_DISP:     DS.W  1                  ; effort display value

;UPDATE_COUNT: DS.B  1                  ; counter for display update
;UPDATE_FLG1   DS.B  1                  ; Boolean for display update for line one
UPDATE_FLG2   DS.B  1                  ; Boolean for display update for line two

KEY_BUF:      DS.B  1                  ; 1-byte buffer for most recent key entry
KEY_FLG:      DS.B  1                  ; Boolean for key available

INTERVAL:     DS.W  1                  ; number of ticks between interrupts

COUNT:        DS.B  1                  ; number of digits successfully captured
BUFFER:       DS.B  5                  ; buffer for ASCII digits

t1state:      DS.B  1                  ; state variables
t2state:      DS.B  1
t3state:      DS.B  1
t4state:      DS.B  1
t5state:      DS.B  1
t6state:      DS.B  1

ECHO:         DS.B  1                  ; Boolean to echo last digit
ECHO_SIGN:    DS.B  1                  ; Boolean to echo '+' or '-' sign 
B_SPACE:      DS.B  1                  ; backspace flag
V_ref_prep:   DS.B  1                  ; Boolean for prepping V_ref entry
KP_prep:      DS.B  1                  ; Boolean for prepping KP entry
KI_prep:      DS.B  1                  ; Boolean for prepping KI entry
update_L1:    DS.B  1                  ; Boolean for update of LCD line_1
update_L2:    DS.B  1                  ; Boolean for update of LCD line_2
D_RUN:        DS.B  1                  ; Boolean to toggle RUN
D_LOOP:       DS.B  1                  ; Boolean to toggle CL/|OL
D_DISP:       DS.B  1                  ; Boolean to toggle auto-display mode
D_HCUR:       DS.B  1                  ; Boolean to hide LCD curson off screen

MOTOR_POWER:  DS.W  1                  ; motor actuation value
P_POWER:      DS.W  1                  ; P-term of motor actuation value
I_POWER:      DS.W  1                  ; I-term of motor actuation value

CURRENT:      DS.W  1                  ; motor current in mA


Lib_IF: SECTION

BSPACE        EQU   $08
ENT           EQU   $0A
SPACE         EQU   $20

TIOS          EQU   $0040
TCNT          EQU   $0044
TSCR          EQU   $0046
TCTL2         EQU   $0049
TMSK1         EQU   $004C
TFLG1         EQU   $004E
TC0           EQU   $0050
TimerEN       EQU   %10000000          ; timer enable bit
C0F           EQU   %00000001          ; timer channel 0 output compare bit
PORTT         EQU   $0240              ; PORTT pin 8 to be used for interrupt timing
DDRT          EQU   $0242

RNST_LOC      EQU   $5C                ; location for RUN/STP display
LOOP_LOC      EQU   $60                ; location for CL/OL display
DISP_LOC      EQU   $63                ; location for D_ON/D_OFF display
LOWER_LIM     EQU   -625               ; number for max reverse duty cycle
UPPER_LIM     EQU   625                ; number for max forward duty cycle

IFENTRY:   

        
        clr   t1state                  ; initialize all tasks to state0
        clr   t2state
        clr   t3state
        clr   t4state
        clr   t5state
        clr   t6state
        
              
        
Loop:
        jsr   TASK_1
        jsr   TASK_2
        jsr   TASK_3
        jsr   TASK_4
        bra   Loop
;
;
;=============TASK_1: Timer Channel 0==================================================
;
TASK_1: ldab  t1state                  ; get current t1state
        clra                           ; extend state variable to two bytes
        cpd   #1
        bls   jumptable_1              ; and branch accordingly
        rts                            ; undefined state - do nothing
        
jumptable_1:
        lsld                           ; mult t1state by 2 to prepare for jump table
        jmp [D, PC]
        DC.W  t1state0
        DC.W  t1state1

t1state0:                              ; initialization for TASK_1
; init PORTT pin 8 for timing the control ISR
        bclr  PORTT, $80               ; clear PORTT pin 8
        bset  DDRT, $80                ; make PORTT pin 8 an output pin
; timer initialization
        movw  #20000, INTERVAL         ; set interrupt period for 0.1 msec
        bset  TIOS, C0F                ; set timer ch0 for output compare (2.1)
        bset  TCTL2, $01               ; set ch0 to toggle output (2.2)
        bclr  TCTL2, $02               ;   for debugging purposes (2.2)
        movb  #$01, t1state            ; set next state

; start TC1 output compare interrupts
        bset  TFLG1, C0F               ; clear C0F done flag before starting (2.3)
        cli                            ; enable interrupts (enabled already?)(2.4)
        bset  TMSK1, C0F               ; enable ch0 TOC interrupts (2.5)
        bset  TSCR, $A0                ; start timer & disable timer in BA...GND (3.1)
        ldd   TCNT                     ; get current count (3.2)
        addd  INTERVAL                 ; set ch0 to go off in INTERVAL counts (3.3)
        std   TC0                      ; set new TC0 value (3)
        rts

t1state1:                              ; stub state - interrupts run continually
t1s1a:  rts                            ; end TASK_1

;
;=============TASK_2: MasterMind=======================================================
;      
TASK_2: ldab  t2state                  ; get current t2state
        clra                           ; extend state variable to two bytes
        cpd   #$0E 
        bls   jumptable_2              ; and branch accordingly
        rts                            ; undefined state - do nothing
        
jumptable_2:
        lsld                           ; mult t2state by 2 to prepare for jump table
        jmp [D, PC]
        DC.W  t2state0
        DC.W  t2state1
        DC.W  t2state2
        DC.W  t2state3
        DC.W  t2state4
        DC.W  t2state5
        DC.W  t2state6
        DC.W  t2state7
        DC.W  t2state8
        DC.W  t2state9
        DC.W  t2stateA
        DC.W  t2stateB
        DC.W  t2stateC
        DC.W  t2stateD
        DC.W  t2stateE
        
t2state0:                              ; TASK_2 initialization to default values
        clr   RUN                      ; init controller state
        movb  #$01, CL
        movb  #$01, DISP_ON
        
        clr   V_entry                  ; initialize entry flags and sign buffer
        clr   KP_entry
        clr   KI_entry
        clr   NEG_FLG
        clr   SIGN_FLG
        
        movb  #$01, D_RUN              ; initialize controller/display flags
        movb  #$01, D_LOOP
        movb  #$01, D_DISP
        movb  #$01, D_HCUR
        clr   ECHO
        clr   ECHO_SIGN
        clr   B_SPACE
        clr   V_ref_prep
        clr   KP_prep
        clr   KI_prep
        clr   update_L1
        clr   update_L2
        clr   UPDATE_FLG1
;;;        clr   UPDATE_COUNT

        clr   COUNT
        
        clra                           ; blank entry spaces in LCD buffers
        ldx   #LVREF_BUF               ;   and initialize controller variables
t2s0a:
        movb  #SPACE, A,X
        inca
        cmpa  #32
        bls   t2s0a
        movw  #0, V_ref                ; Vref, V_act,ERR and EFF default to zero
        ldd   V_ref                    ;   and set the display buffer accordingly
        ldy   #LVREF_BUF+1
        jsr   Bin_2_ASCII
        movw  #0, V_act                ; init Vact to zero
        ldd   V_act                    ;   and set the display buffer accordingly
        ldy   #LVACT_BUF+1
        jsr   Bin_2_ASCII
        movw  #0, ERR                  ; init ERR to zero
        ldd   ERR                      ;   and set the display buffer accordingly
        ldy   #LERR_BUF+1
        jsr   Bin_2_ASCII
        movw  #0, EFF                  ; init EFF to zero
        ldd   EFF                      ;   and set the display buffer accordingly
        ldy   #LEFF_BUF+1
        jsr   Bin_2_ASCII
        movw  #717, KP                ; init KP such that 1024*KP=717 [KP=0.7]
        ldd   KP                       ;   and set the display buffer accordingly
        ldy   #LKP_BUF
        jsr   Bin_2_ASCII
        movw  #230, KI                ; init KI such that 1024*KI=230 [KI=0.225]
        ldd   KI                       ;   and set the display buffer accordingly
        ldy   #LKI_BUF
        jsr   Bin_2_ASCII
        movw  #$0001, Kscale           ; factor for compatibility with 2019 hardware
;;;        clrw  ESUM                     ; init ESUM to zero
        movb  #$01, t2state            ; set next state
        
        jsr   STARTUP_ATD1             ; initialize controller hardware
        jsr   STARTUP_PWM
        jsr   STARTUP_ENCODER
        jsr   STARTUP_MOTOR
        jsr   ENABLE_MOTOR
        jsr   READ_ENCODER             ; read encoder position and 
        std   Theta_OLD                ;   store as Theta_OLD
        
        rts


t2state1:                              ; HUB STATE to DECODE INPUTS
        tst   KEY_FLG                  ; check for key stroke
        bne   t2s1a                    ; skip over exit code if char available
        lbra  t2s1l                    ; if no char available go test UPDATE_FLG
t2s1a:  clr   KEY_FLG                  ; done with test of KEY_FLG, so clear KEY_FLG
        ldab  KEY_BUF                  ; get character
        cmpb  #$F1                     ; compare to F1 key value
        bne   t2s1b                    ; skip over if not appropriate
        movb  #$02, t2state            ; set t2state for F1 state
        lbra  exit_t2s1                ;   and return
t2s1b:  cmpb  #$F2                     ; compare to F2 key value
        bne   t2s1c                    ; skip over if not appropriate
        movb  #$03, t2state            ; set t2state for F2 state
        lbra  exit_t2s1                ;   and return
t2s1c:  cmpb  #BSPACE                  ; compare to <backspace>
        bne   t2s1d                    ; skip over if not appropriate
        movb  #$04, t2state            ; set t2state for backspace state
        lbra  exit_t2s1                ;   and return
t2s1d:  cmpb  #ENT                     ; compare to <ENT>
        bne   t2s1e                    ; skip over if not appropriate
        movb  #$05, t2state            ; set t2state for enter state
        lbra  exit_t2s1                ;   and return
t2s1e:  cmpb  #'A'                     ; compare to <A>
        bne   t2s1f                    ; skip over if not appropriate
        movb  #$06, t2state            ; set t2state for A-state
        lbra  exit_t2s1                ;   and return
t2s1f:  cmpb  #'B'                     ; compare to <B>
        bne   t2s1g                    ; skip over if not appropriate
        movb  #$07, t2state            ; set t2state for B-state
        lbra  exit_t2s1                ;   and return
t2s1g:  cmpb  #'C'                     ; compare to <C>
        bne   t2s1h                    ; skip over if not appropriate
        movb  #$08, t2state            ; set t2state for C-state
        lbra  exit_t2s1                ;   and return
t2s1h:  cmpb  #'D'                     ; compare to <D>
        bne   t2s1i                    ; skip over if not appropriate
        movb  #$09, t2state            ; set t2state for D-state
        lbra  exit_t2s1                ;   and return
t2s1i:  cmpb  #'E'                     ; compare to <E>
        bne   t2s1j                    ; skip over if not appropriate
        movb  #$0A, t2state            ; set t2state for E-state
        lbra  exit_t2s1                ;   and return 
t2s1j:  cmpb  #'F'                     ; compare to <F>
        bne   t2s1k                    ; skip over if not appropriate
        movb  #$0B, t2state            ; set t2state for F-state
        lbra  exit_t2s1                ;   and return
t2s1k:  cmpb  #$30                     ; character less than digit?
        blo   exit_t2s1                ; not a valid digit, simply return
        cmpb  #$39                     ; character greater than a digit?
        bhi   exit_t2s1                ; not a valid, simply return
        movb  #$0C, t2state            ; set t2state for digit state
t2s1l:  tst   UPDATE_FLG1              ; check if time to auto-update line 1
        beq   exit_t2s1                ; if not time to update, simply return
        movb  #$0D, t2state            ;   otherwise, set t2state for UPDATE-state
exit_t2s1:
        rts

t2state2:                              ; F1
        tst   V_entry                  ; if not entering V_ref, or SIGN_FLG is 
        beq   exit_t2s2                ;   not zero, ignore F1
        tst   SIGN_FLG
        bne   exit_t2s2
        tst   COUNT                    ; if COUNT is not zero, ignore F1
        bne   exit_t2s2
        movb  #$01, SIGN_FLG           ; otherwise, set SIGN_FLG = 1 and
        movb  #$01, ECHO_SIGN          ;   set ECHO_SIGN = 1      
exit_t2s2:
        movb  #$01, t2state            ; set next state back to hub
        rts

t2state3:                              ; F2
        tst   V_entry                  ; if not entering V_ref, or SIGN_FLG is 
        beq   exit_t2s3                ;   not zero, ignore F2
        tst   SIGN_FLG
        bne   exit_t2s3
        tst   COUNT                    ; if COUNT is not zero, ignore F1
        bne   exit_t2s3
        movb  #$01, NEG_FLG            ; in negative, set flags accordingly and     
        movb  #$01, SIGN_FLG          ;   and request DISPLAY to write '-'
        movb  #$01, ECHO_SIGN
exit_t2s3:
        movb  #$01, t2state            ; set next state back to hub
        rts

t2state4:                              ; BACKSPACE
        tst   COUNT                    ; if COUNT = 0, check for sign to erase
        bne   t2s4a                    ;   if COUNT = 0, and no sign issued,
        tst   SIGN_FLG                 ;   BACKSPACE does nothing
        beq   exit_t2s4                ; however, if COUNT = 0 and sign has been issued
        clr   SIGN_FLG                 ;   clear the sign flag, and
        clr   NEG_FLG                  ;   and clear the negative flag
        bra   t2s4b                    ; then branch to have sign removed from LCD
        
t2s4a:  dec   COUNT                    ; reduce digit count,
t2s4b:  movb  #$01, B_SPACE            ; set B_SPACE to have a char removed from LCD
exit_t2s4:
        movb  #$01, t2state            ; set next state back to hub
        rts

t2state5:                              ; ENTER
        tst   COUNT
        bne   t2s5b                    ; if COUNT is not 0, process entered digits   
        tst   V_entry                  ; else if COUNT = 0  then test V_entry, and 
        beq   t2s5a                    ;   if V_entry = 0, skip to clean up and 
        clr   SIGN_FLG                 ;   ignore <ENT>
        clr   NEG_FLG                  ; else if V_entry = 1, clear SIGN_FLG, NEG_FLG,
        clr   V_entry                  ;   and V_entry  
        bra   t2s5f                    ; and then skip down to ignore <ENT>
        
t2s5a:  clr   KP_entry                 ; clear all entry flags
        clr   KI_entry                 ;   and ignore <ENT>
        bra   t2s5f                    ; go request update and exit

t2s5b:  jsr   ASCII_2_Bin              ; convert to put magnitude in X
        tst   V_entry                  ; check if entering V_ref
        beq   t2s5d
        movb  #SPACE, LVREF_BUF        ; blank sign byte of LVREF_BUF as the default
        stx   V_ref                    ; if V_enter = 1, store binary number as V_ref
        tst   NEG_FLG                  ; determine sign of V_ref entry
        beq   t2s5c
        movb  #'-', LVREF_BUF          ; if negative, put '-' in leading location in 
        negx                           ;   V_ref buffer, and take the 2s complement
        stx   V_ref                    ;   and store that value as V_ref 
        negx                           ; then convert back to magnitude for buffer
  
t2s5c:  tfr   X,D
        ldy   #LVREF_BUF+1
        jsr   SM_BUF_blank
        jsr   Bin_2_ASCII              ; A contains digit count on return
        clr   SIGN_FLG
        clr   NEG_FLG
        clr   COUNT
        clr   V_entry
        bra   t2s5f
        
t2s5d:  tst   KP_entry
        beq   t2s5e
        stx   KP
        tfr   X,D
        ldy   #LKP_BUF
        jsr   LG_BUF_blank
        jsr   Bin_2_ASCII
        clr   COUNT
        clr   KP_entry
        bra   t2s5f
        
t2s5e:  tst   KI_entry
        beq   exit_t2s5           
        stx   KI
        tfr   X,D
        ldy   #LKI_BUF
        jsr   LG_BUF_blank
        jsr   Bin_2_ASCII
        clr   COUNT
        clr   KI_entry
                        
t2s5f:
        movb  #$01, update_L1          ; update the screen
        movb  #$01, update_L2
        movb  #$01, D_RUN
        movb  #$01, D_LOOP
        movb  #$01, D_DISP
        movb  #$01, D_HCUR
        
exit_t2s5:
        movb  #$01, t2state            ; set next state
        rts
           

t2state6:                              ; A-key [toggle RUN]
        tst   KP_entry                 ; changing RUN not allowed during KP_entry
        bne   exit_t2s6                ;   so ignore A-key in this case
        tst   KI_entry                 ; changing RUN not allowed during KI_entry
        bne   exit_t2s6                ;   so ignore A-key in this case
        ldaa  RUN
        eora  #$01                     ; toggle RUN
        staa  RUN                      ; store the toggled RUN
        movb  #$01, D_RUN              ; send request for new RUN to be displayed
exit_t2s6:
        movb  #$01, t2state            ; set next state back to hub
        rts                            
        
t2state7:                              ; B-key [toggle DISP_ON]         
        ldaa  DISP_ON                      
        eora  #$01                     ; toggle DISP_ON
        staa  DISP_ON                  ; store the toggled DISP_ON
        movb  #$01, D_DISP             ; send request for new DISP_ON to be displayed
        movb  #$01, t2state            ; set next state back to hub
        rts
        
t2state8:                              ; C-key [V_ref entry]
        tst   V_entry                  ; ignore <C> if already entering V_ref
        bne   exit_t2s8
        tst   KP_entry                 ; ignore <C> if already entering KP
        bne   exit_t2s8
        tst   KI_entry                 ; ignore <C> if already entering KI
        bne   exit_t2s8
        movb  #$01, V_entry            ; set V_ref_entry flag
        clr   SIGN_FLG
        clr   NEG_FLG
        movb  #$01, V_ref_prep         ; set V_ref_prep flag for DISPLAY
exit_t2s8:
        movb  #$01, t2state           
        rts                            ; set next state back to hub
        
t2state9:                              ; D-key [stop motor, then handle KP entry]                           
        tst   V_entry                  ; ignore <D> if already entering V_ref
        bne   exit_t2s9
        tst   KP_entry                 ; ignore <D> if already entering KP
        bne   exit_t2s9
        tst   KI_entry                 ; ignore <D> if already entering KI
        bne   exit_t2s9
        clr   RUN                      ; stop the motor
        movb  #$01, D_RUN              ; send request for new RUN to be displayed
        movb  #$01, KP_prep            ; set KP_prep flag for DISPLAY
        movb  #$01, KP_entry           ; set KP_entry flag
exit_t2s9:
        movb  #$01, t2state            ; set next state back to hub
        rts                           
        
t2stateA:                              ; E-key  [stop motor, then handle Ki entry]
        tst   V_entry                  ; ignore <E> if already entering V_ref
        bne   exit_t2sA
        tst   KP_entry                 ; ignore <E> if already entering KP
        bne   exit_t2sA
        tst   KI_entry                 ; ignore <E> if already entering KI
        bne   exit_t2sA
        tst   CL                       ; KI entry not allowed unless CL = 1
        bne   t2sAa                    ;   otherwise, ignore F2
        bra   exit_t2sA
t2sAa:  clr   RUN                      ; stop the motor
        movb  #$01, D_RUN              ; send request for new RUN to be displayed
        movb  #$01, KI_prep            ; set KI_prep flag for DISPLAY
        movb  #$01, KI_entry           ; set KI_entry flag
exit_t2sA:
        movb  #$01, t2state            ; set next state back to hub

        rts                            
        
t2stateB:                              ; F-key [toggle CL, and kill integral
                                       ;   action f CL = 0 (open-loop control)]
        tst   V_entry                  ; BUT first make sure there is no active
        bne   exit_t2sB                ;   data entry in progress
        tst   KP_entry
        bne   exit_t2sB
        tst   KI_entry
        bne   exit_t2sB
        ldaa  CL
        eora  #$01                     ; toggle CL
        staa  CL                       ; store the toggled CL
        bne   t2sBa                    ; if CL = 1, skip over killing the 
        clrw  KI                       ;   integral action to prevent saturation
        clrw  ESUM
        
        movb  #$01, D_HCUR
t2sBa:  movb  #$01, D_LOOP             ; send request for new CL to be displayed
        movb  #$0E, t2state            ; set next state to UPDATE_L2
        rts
        
exit_t2sB:
        movb  #$01, t2state            ; set next state back to hub
        rts
        
t2stateC:                              ; DIGIT
        tst   V_entry                  ; if entry active, process the digit
        bne   t2sC1                    ;   otherwise, ignore the digit
        tst   KP_entry
        bne   t2sC2
        tst   KI_entry
        bne   t2sC2
        beq   exit_t2sC

t2sC1:  ldx   #BUFFER
        ldaa  COUNT
        cmpa  #$03
        bhs   exit_t2sC                ; at 3 digits already, so ignore
        ldab  KEY_BUF                  ;   otherwise, get digit
        stab  A,X                      ; store digit in BUFFER
        inc   COUNT
        movb  #$01, ECHO
        bra   exit_t2sC
        
t2sC2:  ldx   #BUFFER
        ldaa  COUNT
        cmpa  #$05
        bhs   exit_t2sC                ; at 5 digits already, so ignore
        ldab  KEY_BUF                  ;   otherwise, get digit
        stab  A,X                      ; store digit in BUFFER
        inc   COUNT
        movb  #$01, ECHO
exit_t2sC:
        movb  #$01, t2state            ; set next state back to hub
        rts
                                    
t2stateD:                              ; UPDATE LINE_1
        tst   DISP_ON                  ; simply return if the display is not active
        beq   exit_t2sD                ;   otherwise, perform a line-one update
        ldy   #LVACT_BUF+1              
        jsr   SM_BUF_blank             ; clear old value from LVACT_BUF, then get 
        ldd   V_act_DISP               ;   the display copy of V_act and store it in
        bpl   t2sDa                    ;   display buffer leaving room for a sign
        movb  #'-', -1,Y               ; if negative, put a leading minus sign in 
        coma                           ;   the buffer and take the 2s complement
        comb                           ;   of the number
        addd  #$01
        bra   t2sDb 
t2sDa:  movb  #' ', -1,Y               ; if positive, blank intial space
t2sDb:  jsr   Bin_2_ASCII              ;   fill display buffer leaving room for a sign            
        
        ldy   #LERR_BUF+1 
        jsr   SM_BUF_blank             ; clear old value from LERR_BUF, then get
        ldd   ERR_DISP                 ;   the display copy of ERR and store it in 
        bpl   t2sDc                    ;   display buffer leaving room for a sign
        movb  #'-', -1,Y               ; if negative, put a leading minus sign in 
        coma                           ;   the buffer and take the 2s complement
        comb                           ;   of the number
        addd  #$01
        bra   t2sDd 
t2sDc:  movb  #' ', -1,Y               ; if positive, blank intial space
t2sDd:  jsr   Bin_2_ASCII              ;   display buffer leaving room for a sign
        cmpa  #$03                     ; check for too many digits
        ble   t2sDe                    ; branch over saturation feature if okay
        ldx   #LERR_BUF+1
        movb  #'O', 0,X                ; otherwise, fill buffer with XXX
        movb  #'V', 1,X
        movb  #'F', 2,X
        movb  #0, 3,X                  ; restore end-of-buffer to ASCII null

t2sDe:
        ldy   #LEFF_BUF+1
        jsr   SM_BUF_blank             ; clear old value from LEFF_BUF, then get
        ldd   EFF_DISP                 ;   the display copy of EFF and store it in 
        bpl   t2sDf                    ;   display buffer leaving room for a sign
        movb  #'-', -1,Y               ; if negative, put a leading minus sign in 
        coma                           ;   the buffer and take the 2s complement
        comb                           ;   of the number
        addd  #$01
        bra   t2sDg
t2sDf:  movb  #' ', -1,Y               ; if positive, blank intial space 
t2sDg:  jsr   Bin_2_ASCII              ;   display buffer leaving room for a sign 
        
        movb  #$01, update_L1          ; request a line_1 update
exit_t2sD:
        clr   UPDATE_FLG1
        movb  #$01, t2state            ; set next state back to hub
        rts                            
        
        
t2stateE:                              ; UPDATE LINE_2
        ldy   #LKP_BUF
        jsr   LG_BUF_blank             ; blank the KP buffer
        ldd   KP                       ; load KP, convert to ASCII, and 
        jsr   Bin_2_ASCII              ;   set the display buffer accordingly
        ldy   #LKI_BUF
        jsr   LG_BUF_blank             ; blank the KI buffer
        ldd   KI                       ; load KP, convert to ASCII, and                      
        jsr   Bin_2_ASCII              ;   set the display buffer accordingly

        movb  #$01, update_L2          ; request a line_2 update
        clr   UPDATE_FLG2
        movb  #$01, t2state            ; set next state back to hub
        rts                         
;
;
;
;==============TASK_3:Keypad_Driver===============================================
;
TASK_3: ldab  t3state                  ; get current t3state
        clra                           ; extend state variable to two bytes
        cpd   #2 
        bls   jumptable_3              ; and branch accordingly
        rts                            ; undefined state - do nothing
        
jumptable_3:
        lsld                           ; mult t3state by 2 to prepare for jump table
        jmp [D, PC]        
        DC.W  t3state0
        DC.W  t3state1
        DC.W  t3state2

t3state0:                              ; TASK_3 INITIALIZATION
        jsr   INITKEY                  ; initialize keypad
        clr   KEY_FLG                  ; clear key available flag
        movb  #$01, t3state            ; set next state
        rts

t3state1:                              ; WAITING FOR KEY
        tst   LKEY_FLG                 ; check for a key stroke
        beq   t3s1a
        jsr   GETCHAR                  ; get char if available
        stab  KEY_BUF                  ; store key
        movb  #$01, KEY_FLG            ; set key available flag
        movb  #$02, t3state            ; set next state
t3s1a:  rts

t3state2:                              ; WAITING FOR KEY_ACKNOWLEDGE
        tst   KEY_FLG                  ; check KEY_FLG handshake
        bne   t3s2a
        movb  #$01, t3state            ; set next state
t3s2a:  rts                            ; end TASK_3
;
;
;
;==============TASK_4:Display==========================================================
;
 TASK_4: 
        ldab  t4state                  ; get current t4state
        clra                           ; extend state variable to two bytes
        cpd   #$D 
        bls   jumptable_4              ; and branch accordingly
        rts                            ; undefined state - do nothing
        
jumptable_4:
        lsld                           ; mult t4state by 2 to prepare for jump table
        jmp [D, PC]        
        DC.W  t4state0
        DC.W  t4state1
        DC.W  t4state2
        DC.W  t4state3
        DC.W  t4state4
        DC.W  t4state5
        DC.W  t4state6
        DC.W  t4state7
        DC.W  t4state8
        DC.W  t4state9
        DC.W  t4stateA
        DC.W  t4stateB
        DC.W  t4stateC
        DC.W  t4stateD

t4state0:                              ; TASK_4 INITIALIZATION
        jsr   INITLCD                  ; initialize the LCD module
        jsr   LCDTEMPLATE              ; initialize the controller screen
        jsr   UPDATELCD_L1             
        jsr   UPDATELCD_L2
        ldaa  #$36                     ; hide the cursor
        jsr   SETADDR                 
        jsr   CURSOR_ON                ; turn CURSOR ON
        movb  #$01, t4state            ; set next state
        rts

t4state1:                              ; DISPLAY HUB
        tst   ECHO
        beq   t4s1a
        movb  #$02, t4state            ; set next state
        rts 

t4s1a:  tst   ECHO_SIGN
        beq   t4s1b
        movb  #$03, t4state            ; set next state
        rts 
             
t4s1b:  tst   B_SPACE
        beq   t4s1c
        movb  #$04, t4state
        rts
        
t4s1c:  tst   V_ref_prep
        beq   t4s1d
        movb  #$05, t4state            ; set next state
        rts
        
t4s1d:  tst   KP_prep
        beq   t4s1e
        movb  #$06, t4state            ; set next state
        rts
        
t4s1e:  tst   KI_prep
        beq   t4s1f  
        movb  #$07, t4state            ; set next state
        rts
        
t4s1f:  tst   update_L1
        beq   t4s1g
        movb  #$08, t4state            ; set next state
        rts

t4s1g:  tst   update_L2
        beq   t4s1h
        movb  #$09, t4state            ; set next state
        rts

t4s1h:  tst   D_RUN
        beq   t4s1i
        movb  #$0A, t4state            ; set next state
        rts
        
t4s1i:  tst   D_LOOP
        beq   t4s1j
        movb  #$0B, t4state            ; set next state
        rts
                                    
t4s1j:  tst   D_DISP
        beq   t4s1k
        movb  #$0C, t4state            ; set next state
        rts
                                    
t4s1k:  tst   D_HCUR
        beq   t4s1l
        movb  #$0D, t4state            ; set next state
        rts
        
t4s1l:  rts                            ; undefined state - do nothing

t4state2:                              ; ECHO DIGIT
        ldaa  COUNT                    ; get character COUNT
        ldx   #BUFFER                  ; get base address
        deca                           ; adjust to point to last char
        ldab  A,X                      ; get char
        jsr   OUTCHAR                  ; echo char to LCD
        clr   ECHO
        movb  #$01, t4state            ; done, so set next state
        rts

t4state3:                              ; ECHO SIGN
        tst   NEG_FLG                  ; check for '-' sign
        beq   t4s3a
        ldab  #'-'                     ; load up '-' character
        bra   t4s3b
t4s3a:  ldab  #'+'                     ; load up '+' character
t4s3b:  jsr   OUTCHAR                  ; display the proper sign
        clr   ECHO_SIGN
exit_t4s3:
        movb  #$01, t4state            ; done, so set next state
        rts

t4state4:                              ; B_SPACE
        ldx   #BSPACE_FM
        jsr   OUTSTRING
        clr   B_SPACE
        movb  #$01, t4state            ; done, so set next state
        rts        

t4state5:                              ; V_ref_prep
        ldaa  #$40                     ; blank out space in lower left of LCD screen
        ldx   #BLANK27
        jsr   OUTSTRING_AT
        ldaa  #$40
        ldx   #VREF_PRMPT              ; print V_ref prompt
        jsr   OUTSTRING_AT
        ldaa  #$4A
        jsr   SETADDR                  ; set cursot to proper postion for V_ref entry
        movb  #$01, V_entry
        clr   V_ref_prep
        movb  #$01, t4state            ; done, so set next state
        rts 

t4state6:                              ; KP_prep
        ldaa  #$48
        ldx   #BLANK5
        jsr   OUTSTRING_AT             ; blank out current value of KP
        ldaa  #$48                     ; set cursor to proper position for KP_entry
        jsr   SETADDR
        clr   KP_prep 
        movb  #$01, t4state            ; done, so set next state
        rts 

t4state7:                              ; KI_prep
        ldaa  #$56
        ldx   #BLANK5
        jsr   OUTSTRING_AT             ; blank out current value of KI
        ldaa  #$56                     ; set cursor to proper position for KI_entry
        jsr   SETADDR
        clr   KI_prep 
        movb  #$01, t4state            ; done, so set next state
        rts 

t4state8:                              ; UPDATE LINE_1
        jsr   GETADDR                  ; save cursor location on stack in case
        psha                           ;   currently entering V_ref on L2
        jsr   UPDATELCD_L1
        pula
        jsr   SETADDR                  ; restore cursor location
        clr   update_L1
        movb  #$01, t4state            ; done, so set next state
        rts

t4state9:                              ; UPDATE LINE_2
        ldaa  #$40
        ldx   #L2_TEMPLATE
        jsr   OUTSTRING_AT
        jsr   UPDATELCD_L2
        movb  #$01, D_HCUR
        clr   update_L2
        movb  #$01, t4state            ; done, so set next state
        rts

t4stateA:                              ; DISPLAY RUN/STP
        jsr   GETADDR                  ; save cursor location on stack
        psha
        ldaa  RUN
        bne   t4sAa
        ldx   #STP_MESS
        bra   t4sAb
t4sAa:  ldx   #RUN_MESS
t4sAb:  ldaa  #RNST_LOC
        jsr   OUTSTRING_AT
        clr   D_RUN
        pula
        jsr   SETADDR                  ; restore cursor location
        movb  #$01, t4state            ; done, so set next state
        rts 

t4stateB:                              ; DISPLAY CL/OL
        jsr   GETADDR                  ; save cursor location on stack
        psha
        ldaa  CL
        bne   t4sBa
        ldx   #OL_MESS
        bra   t4sBb
t4sBa:  ldx   #CL_MESS
t4sBb:  ldaa  #LOOP_LOC
        jsr   OUTSTRING_AT
        clr   D_LOOP
        pula
        jsr   SETADDR                  ; restore cursor location
        movb  #$01, t4state            ; done, so set next state
        rts 
                              
t4stateC:                              ; DISPLAY DISP_ON/DISP_OFF 
        jsr   GETADDR                  ; save cursor location on stack
        psha
        ldaa  DISP_ON                  ;
        bne   t4sCa
        ldx   #D_OFF_MESS
        bra   t4sCb
t4sCa:  ldx   #D_ON_MESS
t4sCb:  ldaa  #DISP_LOC
        jsr   OUTSTRING_AT
        clr   D_DISP
        pula
        jsr   SETADDR                  ; restore cursor location
        movb  #01, t4state             ; done, so set next state
        rts                            

t4stateD:                              ; HIDE CURSOR
        ldaa  #$36                     ; load A with address where cursor is hidden
        jsr   SETADDR                  ; hide the cursor
        clr   D_HCUR
        movb  #$01, t4state            ; done, so set next state
        rts                            ; end TASK_4
;
;
;
;/------------------------------------------------------------------------------------\
;| Subroutines                                                                        |
;\------------------------------------------------------------------------------------/
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                             ;
;   SUBROUTINE TOCISR                                         ;
;                                                             ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                             ;
;   This interrupt service routine for timer channel 0 output ;
;   compare interrupts resets the timer for a new interrupt   ;
;   in INTERVAL clock counts.                       ;
;                                                             ;
;   Additionally, the control loop for the Lab 5 motor runs   ;
;   every interrupt.  However, the display is updated         ;
;   every 256 interrupts, which at an interrupt frequency of  ;
;   500 Hz is approximately every one-half second.            ;
;                                                             ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;TC0ISR:
;;;        bset  PORTT, $80               ; turn on PORTT pin 8 to begin ISR timing
        
;;;        inc   UPDATE_COUNT             ; unless UPDATE_COUNT = 0, skip saving
;;;        bne   measurements             ;   display variables
;;;        movw  V_act, V_act_DISP        ; take a snapshot of variables to enable
;;;        movw  ERR, ERR_DISP            ;   consistent display
;;;        movw  EFF, EFF_DISP
;;;        movb  #$01, UPDATE_FLG1        ; set UPDATE_FLG1 when appropriate
        
; Measurements block

;measurements:
; Read encoder value
            
; Compute 2-point difference to get speed
;;;        ldy   #13                      ; comute V_act for the scope
;;;        emuls
;;;        addd  #2048
;;;        jsr   OUTDACA                  ; send the V_act voltage to the scope

; Use speed to compute error            
;store_ERR:
;
;run_test:
;;;        tst   RUN                      ; if RUN is ON, run the controller
;;;        bne   controller               ; otherwise, clear ESUM, and set 
;;;        clrw  ESUM                     ;   the motor duty cycle to zero
;;;        clrw  MOTOR_POWER
;;;        clra                           ;
;;;        clrb
;;;        bra   out_2_motor              ;   and branch down to shut off the motor

; Controller block

;controller:
; Compute Integral (ESUM)           
; Compute integral actuation signal
; Compute proportional actuation signal
; Combine I and P signals to get motor power
; Apply scaling gain
; Make sure the motor driver doesn't brake 
;NOBRAKE:
; Saturate the data and store it
; Store unsaturated motor power

; Send ouput to motor          
;out_2_motor:
; Perform ISR maintenance for next loop

;NOT_YET:
; reset timer for next interrupt 
;;;        rti                            ; exit TOCISR
;-----------Saturator------------------------------------------------------------------

;-----------Saturated Double Byte Addition---------------------------------------------
;-----------Saturated Double Byte Subtraction------------------------------------------
;-----------Saturated Double Byte Multiplication and Divide----------------------------

;=============Subroutine SM_BUF_blank==================================================       
;=                                                                                    =
;=      Loads ASCII spaces in the last three bytes of the buffer address in Y         =
;=                                                                                    =
;======================================================================================
;
SM_BUF_blank:
        movb  #$20, 0,Y
        movw  #$2020, 1,Y
        rts                            ; end subroutine SM_BUF_blank
        
        
;=============Subroutine LG_BUF_blank==================================================       
;=                                                                                    =
;=      Loads ASCII spaces in the five bytes of the buffer address in Y               =
;=                                                                                    =
;======================================================================================
;
LG_BUF_blank:
        movw  #$2020, 0,Y
        movw  #$2020, 2,Y
        movb  #$20, 4,Y
        rts                            ; end subroutine LG_BUF_blank
        
        
        
;=============Subroutine ASCII_2_Bin===================================================       
;=                                                                                    =
;=      Assumes standard COUNT & BUFFER scheme                                        =
;=      Uses stack to avoid needing TEMP space in RAM                                 =
;=      Returns:  saturated result in X such that 0<= X <= 32767                      =
;=                                                                                    =
;======================================================================================
;
ASCII_2_Bin:
        des                           ; make room on the stack for three bytes of heap
        des
        des
        movw  #$0000, 1,SP
        ldx   #BUFFER
        clr   0,SP
conv_loop:
        ldaa  0,SP
        ldab  A,X
        subb  #'0'
        clra      
        addd  1,SP
        bcs   TOO_LARGE                ; branch to saturation if X => 65535
        std   1,SP
        inc   0,SP
        dec   COUNT
        beq   conv_done
        ldy   #$000A
        emul
        cpy   #$0000
        bne   TOO_LARGE                ; branch to saturation if X => 65535
        std   1,SP
        bra   conv_loop
conv_done:
        cpd   #32767
        bls   exit_ASCII_2_Bin         ; if necessary, saturate X to 32767
TOO_LARGE:
        ldd  #32767
exit_ASCII_2_Bin:
        tfr   D,X                      ; put result in X
        ins                            ; remove three bytes of heap from stack
        ins
        ins   
        rts                            ; end subroutine ASCII_2_Bin
;


;=============Subroutine Bin_2_ASCII===================================================       
;=                                                                                    =
;=      Assumes binary number in D and output buffer address in Y                     =
;=      Uses the stack for heap to avoid declaring TEMP storage in RAM                =
;=      Returns:  puts ASCII digits in output buffer and number of digits in A        =
;=                                                                                    =                         
;======================================================================================
;
Bin_2_ASCII:
        des                            ; make room for four bytes of heap on stack
        des
        des
        des
        clr   0,SP                     ; clear character count
        sty   1,SP                     ; save output buffer address on stack
        clr   3,SP                     ; clear final character count
con_loop:
        clry                           ; divide number by 10
        ldx   #$000A                   
        ediv
        pula                           ; get character count
        pshb                           ; store remainder on stack
        inca                           ; increment character count
        psha                           ; store character count on stack
        tsty
        beq   con_top                  ; done if quotient is zero
        tfr   Y, D                     ; load quotient into number
        bra   con_loop                 ; go again
con_top:
        tfr   A,B                      ; put character count in B
        incb                           ; increment B three times to skip over count,
        incb                           ;   and buffer address in addition to the
        incb                           ;   remainders  on the stack
        staa  B,SP                     ; store final character count
unstack_loop:
        pula                           ; get character count
        ldx   A,SP                     ; get buffer address 
        pulb                           ; get least significant remaining remainder
        addb  #'0'                     ; convert remainder to ASCII character
        stab  0,X                      ; store ASCII character in buffer
        inx                            ; increment buffer address
        deca                           ; reduce character count
        beq   con_end                  ; done if no more remainders remaining
        stx   A,SP                     ; store addr of next available space in buffer
        psha                           ; store character count on stack
        bra   unstack_loop
con_end:
        ins
        ins
        pula                           ; return final character count in A
        rts                            ; end subroutine Bin_2_ASCII
;
;
;
;
;=============ASCII Messages===========================================================
;
VREF_PRMPT:   DC.B  'new V_ref=',$00
BSPACE_FM:    DC.B  $08, $20, $08, $00
BLANK4:       DC.B  '    ',$00
BLANK5:       DC.B  '     ',$00
BLANK13:      DC.B  '             ',$00
BLANK27:      DC.B  '                           ',$00
L2_TEMPLATE:  DC.B  '1024*KP=      1024*KI=      ',$00
RUN_MESS:     DC.B  'RUN',$00
STP_MESS:     DC.B  'STP',$00
CL_MESS:      DC.B  'CL',$00
OL_MESS:      DC.B  'OL',$00
D_ON_MESS:    DC.B  'D_ON ',$00
D_OFF_MESS:   DC.B  'D_OFF',$00



;/------------------------------------------------------------------------------------\  
;| Vectors                                                                            | 
;\------------------------------------------------------------------------------------/

; Add interrupt and reset vectors here:
         ORG  $FFCE                  ; reset vector address
         DC.W ISR_KEYPAD                                                                                                             
